{"pages":[{"title":"About","text":"","link":"/about/index.html"},{"title":"","text":"google-site-verification: google94a85560805a7e1e.html","link":"/google94a85560805a7e1e.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/hello-world/"},{"title":"Icarus 主题自定义（基于2.x）","text":"本文是基于icarus 2.x的版本，icarus从3.0开始使用jsx重写了，查看最新版本。 本博客所选取的主题是 Icarus ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 diff，这里记录一些主要的改动。 注: 可以通过变量 page.layout 来判断当前页面类型，'post' 表示当前是文章页面，具体可参考 hexo 文档。 布局文章页面两栏布局主题默认是三栏布局，并且显示了很多的 widget ，但在阅读文章时显得有些拥挤。因此在文章页面，修改为两栏布局，并显示特定的 widget。 diff:includes/helpers/layout.js12345678910 const widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ if (this.page.layout !== 'post') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ }+ if (position === 'left') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));+ } else {+ return []+ } 可以参考上述代码，即可实现不同页面不同 widget。 但两栏整体宽度跟三栏不同。因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 diff:layout/common/widget.ejs123456 &lt;% function side_column_class() { switch (column_count()) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: diff:layout/layout.ejs12345678910-&lt;body class=&quot;is-&lt;%= column_count() %&gt;-column&quot;&gt;+&lt;body class=&quot;is-3-column&quot;&gt; &lt;%- partial('common/navbar', { page }) %&gt; &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2:- return 'is-8-tablet is-8-desktop is-8-widescreen';+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 并修改在不同屏幕小大下的宽度 diff:source/css/style.styl12345678910111213 .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap+ .is-3-column .container+ max-width: screen-widescreen - gap+ width: screen-widescreen - gap @media screen and (min-width: screen-fullhd)+ .is-3-column .container+ max-width: screen-fullhd - 2 * gap+ width: screen-fullhd - 2 * gap .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon。 diff:layout/common/article.ejs1234567891011121314151617 &lt;div class=&quot;card-content article &lt;%= post.hasOwnProperty('direction') ? post.direction : '' %&gt;&quot;&gt;+ &lt;h1 class=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;+ &lt;% if (index) { %&gt;+ &lt;a class=&quot;has-link-black-ter&quot; href=&quot;&lt;%- url_for(post.link ? post.link : post.path) %&gt;&quot;&gt;&lt;i class=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;&lt;%= post.title %&gt;&lt;/a&gt;+ &lt;% } else { %&gt;+ &lt;i class=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;&lt;%= post.title %&gt;+ &lt;% } %&gt;+ &lt;/h1&gt; &lt;% if (post.layout != 'page') { %&gt; &lt;div class=&quot;level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto&quot;&gt; &lt;div class=&quot;level-left&quot;&gt;- &lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;i class=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt;+ &lt;time class=&quot;level-item has-text-grey is-hidden-mobile&quot; datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot;&gt;&lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;+ &lt;% } %&gt; &lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; 其中创建时间使用日期。 diff:source/js/main.js12345- if (typeof(moment) === 'function') {- $('.article-meta time').each(function () {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时也显示 tags，并且将 Read More 按钮放置在右边。 diff:layout/common/article.ejs123456789101112131415161718192021222324252627282930313233343536 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt; &lt;div class=&quot;level is-size-7 is-uppercase&quot;&gt; &lt;div class=&quot;level-start&quot;&gt; &lt;div class=&quot;level-item&quot;&gt;- &lt;span class=&quot;is-size-6 has-text-grey has-mr-7&quot;&gt;#&lt;/span&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp; &lt;%- list_tags(post.tags, { class: 'has-link-grey ', show_count: false,- style: 'link'+ style: 'link',+ separator: ',&amp;nbsp;' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; &lt;% if (index &amp;&amp; post.excerpt) { %&gt;- &lt;div class=&quot;level is-mobile&quot;&gt;+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt;+ &lt;div class=&quot;level is-mobile is-flex&quot;&gt;+ &lt;div class=&quot;level-start&quot;&gt;+ &lt;% if (post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;div class=&quot;level-item is-size-7 is-uppercase&quot;&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;+ &lt;%- list_tags(post.tags, {+ class: 'has-link-grey ',+ show_count: false,+ style: 'link',+ separator: ',&amp;nbsp;'+ }) %&gt;+ &lt;/div&gt;+ &lt;% } %&gt;+ &lt;/div&gt; &lt;div class=&quot;level-start&quot;&gt; 优化个人信息布局减少头像大小，头像下方计数的地方增加链接，follow前增加icon。 diff:layout/widget/profile.ejs1234567- &lt;nav class=&quot;level is-mobile&quot;&gt;+ &lt;nav class=&quot;level menu-list is-mobile&quot; style=&quot;margin-bottom:1rem&quot;&gt; &lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt;- &lt;div&gt;+ &lt;a href=&quot;&lt;%- url_for('/archives/') %&gt;&quot;&gt; &lt;p class=&quot;heading&quot;&gt;...... 优化移动端显示在移动端，隐藏 archive 和 tagcloud。 diff:layout/widget/archive.ejs12-&lt;div class=&quot;card widget&quot;&gt;+&lt;div class=&quot;card widget is-hidden-mobile&quot;&gt; diff:layout/widget/tagcloud.ejs12-&lt;div class=&quot;card widget&quot;&gt;+&lt;div class=&quot;card widget is-hidden-mobile&quot;&gt; 目录粘性布局增加 column-left is-sticky 类。 diff:layout/widget/toc.ejs12-&lt;div class=&quot;card widget&quot; id=&quot;toc&quot;&gt;+&lt;div class=&quot;card widget column-left is-sticky&quot; id=&quot;toc&quot;&gt; 功能增加版权说明diff:layout/common/article.ejs1234567891011121314 &lt;div class=&quot;content&quot;&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt; &lt;/div&gt;+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;+ &lt;ul class=&quot;post-copyright&quot;&gt;+ &lt;li&gt;&lt;strong&gt;本文标题：&lt;/strong&gt;&lt;a href=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;&lt;a href=&quot;&lt;%= theme.url %&gt;&quot;&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文链接：&lt;/strong&gt;&lt;a href=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;发布时间：&lt;/strong&gt;&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 许可协议。转载请注明出处！+ &lt;/li&gt;+ &lt;/ul&gt;+ &lt;% } %&gt; &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 并增加样式 diff:source/css/style.styl12345678+.post-copyright+ font-size: 1rem+ letter-spacing: 0.02rem+ word-break: break-all+ margin: 2.5rem 0 0+ padding: 1rem 1rem+ border-left: 3px solid #FF1700+ background-color: #F9F9F9 增加标题自动计数diff:source/css/style.styl1234567+.article {counter-reset:section}+.article h2{counter-reset:sub-section}+.article h3{counter-reset:composite}+.article h4{counter-reset:detail}+.article h2:before{content:counter(section) &quot; &quot;;counter-increment:section}+.article h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section}+.article h4:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite} 默认显示目录正常开启目录需要在 meta 信息中加入 toc: true 开启，但绝大部分文章都是有目录的，因此修改为默认开启。因为有多个地方引用了 get_config('toc') 并且需要判断当前页面，改起来稍微麻烦一些，因此直接修改了 get_config 方法。 diff:includes/helpers/config.js1234567 return defaultValue; } else { const property = readProperty(specs, configName);- return property === null ? null : property[descriptors.defaultValue];+ const result = property === null ? null : property[descriptors.defaultValue];+ return (configName === 'toc' &amp;&amp; this.page.layout === 'post' &amp;&amp; result === null) ? true : result; } 页面footer显示一组icon默认情况下一个icon对应一个链接，但例如 CC BY-NC-SA 4.0 需要四个图标一组。因此修改代码，使得配置 link.icon 可以是一个数组，效果可以参考页面底部。 diff:layout/common/footer.ejs1234 &lt;% } else { %&gt;- &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt;+ &lt;% for (let icon of (Array.isArray(link.icon) ? link.icon : [link.icon])) { %&gt;&lt;i class=&quot;&lt;%= icon %&gt;&quot;&gt;&lt;/i&gt;&amp;nbsp;&lt;% } %&gt; &lt;% } %&gt; diff:includes/specs/icon_link.spec.js12345 icon: { [required]: true,- [type]: 'string',+ [type]: ['string', 'array'], [doc]: 'Link icon class names' _config.yml 中配置如下 _config.yml123456789footer: links: CC BY-NC-SA 4.0: icon: - fab fa-creative-commons - fab fa-creative-commons-by - fab fa-creative-commons-nc - fab fa-creative-commons-sa url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 可以配置文章开头是否显示图片Icarus 支持文章设置一个图片，在文章开头、最近的文章、时间线等地方显示。但有些图放大之后会显得很不协调，因此修改以支持自定义是否显示。修改 has_thumbnail 方法，增加参数 isArticle 参数，默认 false，并在文章页面修改调用参数。 diff:includes/helpers/page.js1234567891011- hexo.extend.helper.register('has_thumbnail', function (post) {+ hexo.extend.helper.register('has_thumbnail', function (post, isArticle = false) { const getConfig = hexo.extend.helper.get('get_config').bind(this); const allowThumbnail = getConfig('article.thumbnail', true); if (!allowThumbnail) { return false; }+ if (isArticle &amp;&amp; post['article-thumbnail'] === false){+ return false;+ } return post.hasOwnProperty('thumbnail') &amp;&amp; post.thumbnail; diff:layout/common/article.ejs1234 &lt;div class=&quot;card&quot;&gt;- &lt;% if (has_thumbnail(post)) { %&gt;+ &lt;% if (has_thumbnail(post, true)) { %&gt; &lt;div class=&quot;card-image&quot;&gt; 这样修改之后，如果文章 meta 信息中包含 article-thumbnail: false，就可以取消图片的显示。 样式修改 logo 和 favicon用 Python 设计 Logo，并微调样式。 按钮背景颜色增加渐变diff:source/css/style.styl123456 .menu-list li ul margin-right: 0+ .menu-list a+ transition: background-color 0.3s ease-in-out .menu-list a.level display: flex card 增加浮动效果:hover 时增大阴影，并增加动画属性 ease-in-out。 diff:source/css/style.styl12345 .card border-radius: 4px box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1)+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) diff:source/js/animation.js123 element.style.transform = '';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; 更新2020-02-16 合并了 2.7.0 版本，冲突不算太多，有两个点需要注意一下。 icarus 的配置里面，plugins.clipboard 需要移除，相关的配置移动到 article.highlight.clipboard。 _config.yml12345678910article: # Code highlight settings highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: github-gist # Show code copying button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded 如果之前 links widget 没有配置链接，可能会遇到编译错误，需要增加一下判断。 diff:layout/widget/links.locals.js12345 const links = get_config_from_obj(locals.widget, 'links');- if (Object.keys(links).length == 0) {+ if (!links || Object.keys(links).length == 0) { return null; } 总结这里只列举了部分改动，详细的差异可以查看 diff。 本文会持续更新，保持跟最新的博客效果一致，希望能给你自定义主题一些帮助。 如果有其他想法或者意见，可以在下方留言。 😊","link":"/2019/03/customize-icarus-2/"},{"title":"Ubuntu 内核升级","text":"Linux 内核大概几天就会有一个小版本更新，几个月就会有一次主要版本的更新，例如： 2018-10-22 v4.19 2018-12-24 v4.20 2019-03-04 v5.0 2019-03-10 v5.0.1 2019-03-14 v5.0.2 2019-03-19 v5.0.3 为了使用一些新的特性，或者为了提升性能和安全性，或者只是为了修复某些问题，需要对内核进行单独升级。 The Linux Kernel ArchivesUbuntu Kernel Mainline 升级内核正常情况下不会出现问题，但不排除可能会出现问题，请合理评估风险。 查看当前内核版本可以通过 uname 查看当前内核版本， 12$ uname -srLinux 4.4.0-92-generic 或者输入 uname -a 查看完整信息。 Ubuntu 内核升级最好是升级到长期支持版（longterm）本或者稳定版（stable），可以在 The Linux Kernel Archives查看当前的版本，这里以 longterm: 4.19.36 为例。 之后在 Ubuntu Kernel Mainline 找到对应的版本号，https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.36/ 。 在对应的架构Build for xxx succeeded，下载不包含 lowlatency 的所有deb文件。例如在 x86_64 下，总共需要下载4个文件。 1234linux-headers-4.19.36-041936_4.19.36-041936.201904200430_all.deblinux-headers-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deblinux-image-unsigned-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deblinux-modules-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deb 安装 1sudo dpkg -i linux-*.deb 重启 1sudo reboot 确认升级成功 12$ uname -srLinux 4.19.36-041936-generic 这里看到内核版本已经升级成功了，其他版本或者架构操作也类似。 删除旧的内核版本如果确实要移除旧的内核版本，可以通过该命令查看已经安装的内核版本， 1dpkg --get-selections | grep linux 然后直接使用 apt-get purge 删除旧版本的包（有明确的版本号）。 总结还有一些其他方法，例如直接用 apt-get 升级，还有一些工具，具体可以参考 How to update kernel to the latest mainline version without any Distro-upgrade?","link":"/2019/04/kernel-update/"},{"title":"用 Python 设计 Logo","text":"用 Python 设计一个简单的 logo 。 预览logo.svg favicon.svg 代码代码只依赖 matplotlib。 12345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltlines = [[[1, 4], [5, 8.08]], [[1, 4], [5, 1.92]], [[5, 9], [2.96, 7.04]], [[5, 6.5], [7.04, 5.5]], [[8, 9], [4, 2.96]]]color = '#00a4ef'linewidth = 28# favicon.svgplt.figure(figsize=(4, 4))plt.axis('off')plt.axis([0, 10, 0, 10])for l in lines: plt.plot(l[0], l[1], color, linewidth=linewidth)plt.savefig('favicon.svg')# logo.svgplt.figure(figsize=(10, 4))plt.axis('off')plt.axis([0, 25, 0, 10])for l in lines: plt.plot(l[0], l[1], color, linewidth=linewidth)plt.text(11, 2, 'Lxy', fontsize=180)plt.savefig('logo.svg') SVG 压缩压缩SVG可以减少图片大小，尝试了几个在线压缩svg的网站，效果都不太理想，主要是形状处理不准确，跟原图显示不一样。后来试了 https://vecta.io/nano 效果非常好而且压缩率也不错，上述两张图片压缩率超过 60% 。 替换本博客使用的是 icarus 主题，在 themes/icarus/source/img 目录下替换 favicon.svg 和 logo.svg 即可，其他主题操作也类似。","link":"/2019/03/python-logo/"},{"title":"Icarus 主题自定义","text":"本文是基于icarus 4.x的版本，icarus在2.0使用的是ejs，如果需要请查看旧版本。 本博客所选取的主题是 Icarus ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 diff，这里记录一些主要的改动。 布局文章页面两栏布局主题默认是三栏布局，在阅读文章时显得有些拥挤。可以通过配置的方式把所有文章变为两栏布局，在_config.post.yml把需要的widget显示在一边即可，可以参考官方文档。 但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 diff:layout/layout.jsx1234 &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; diff:layout/layout.jsx1234 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 diff:layout/common/widgets.jsx12345678 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 并优化在不同屏幕小大下的宽度 diff:include/style/responsive.styl1234567891011121314151617 +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon diff:layout/common/article.jsx123456789101112131415161718192021222324252627282930313233 &lt;article class={`card-content article${'direction' in page ? ' ' + page.direction : ''}`} role=&quot;article&quot;&gt; {/* Metadata */}+ {/* Title */}+ &lt;h1 className=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;+ {index ?+ &lt;a className=&quot;has-link-black-ter&quot; href={url_for(page.link || page.path)}&gt;+ &lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;{page.title}+ &lt;/a&gt; :+ [&lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;, page.title]+ }+ &lt;/h1&gt; {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; &lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */}- {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.created_at', `&lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${new Date(page.date).toLocaleString()}&quot;&gt;${date(page.date)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {page.date &amp;&amp; &lt;span class=&quot;level-item&quot;&gt;+ &lt;i className=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime={date_xml(page.date)} title={date_xml(page.date)}&gt;{date(page.date)}&lt;/time&gt;+ &lt;/span&gt;} {/* Last Update Date */}- {page.updated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${new Date(page.updated).toLocaleString()}&quot;&gt;${date(page.updated)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item is-hidden-mobile&quot;&gt;+ &lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime={date_xml(page.updated)} title={date_xml(page.updated)}&gt;{date(page.updated)}&lt;/time&gt;+ &lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} 其中时间直接使用日期 diff:source/js/main.js12345- if (typeof moment === 'function') {- $('.article-meta time').each(function() {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时（主页）也显示 tags，并且将 Read More 按钮放置在右边。 diff:layout/common/article.jsx123456789101112131415161718192021 {/* Licensing block */} {!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null}+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt;+ &lt;div className=&quot;level is-mobile is-flex&quot;&gt; {/* Tags */}- {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt;- &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt;- {page.tags.map(tag =&gt; {- return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;;+ {page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 is-uppercase&quot;&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;+ {page.tags.map((tag, index) =&gt; {+ return &lt;a class=&quot;link-muted&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}{index !== page.tags.length-1? ', ':''}&lt;/a&gt;; })} &lt;/div&gt; : null} {/* &quot;Read more&quot; button */}- {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null}+ {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;&lt;i class=&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{__('article.more')}&lt;/a&gt; : null}+ &lt;/div&gt; {/* Share button */} 优化个人信息布局减少头像大小，头像下方计数的地方增加链接，follow前增加icon。 diff:layout/widget/profile.jsx123456789101112- &lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt;+ &lt;a class=&quot;level-item has-text-centered is-marginless&quot; href={counter.category.url}&gt; &lt;div&gt; &lt;p class=&quot;heading&quot;&gt;{counter.category.title}&lt;/p&gt;- &lt;a href={counter.category.url}&gt;+ &lt;div&gt; &lt;p class=&quot;title&quot;&gt;{counter.category.count}&lt;/p&gt;- &lt;/a&gt;+ &lt;/div&gt; &lt;/div&gt;- &lt;/div&gt;+ &lt;/a&gt; 优化移动端显示在移动端，隐藏 archive 和 tags。 diff:source/js/main.js12345 }++ $('div.container div.card[data-type=tags]').addClass('is-hidden-mobile');+ $('div.container div.card[data-type=archives]').addClass('is-hidden-mobile'); }(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings)); 目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 diff:source/js/main.js123 if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); diff:include/style/widget.styl123+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 功能增加默认缩略图diff:layout/layout.jsx12345 const { site, config, page, helper, body } = this.props;+ site.posts &amp;&amp; site.posts.filter(p =&gt; !p.thumbnail).forEach(p =&gt; p.thumbnail = '/img/thumbnail.svg');+ const language = page.lang || page.language || config.language; diff:layout/archive.jsx12345 const { url_for, __, date_xml, date } = helper;+ page.posts &amp;&amp; page.posts.filter(p =&gt; !p.thumbnail).forEach(p =&gt; p.thumbnail = '/img/thumbnail.svg');+ const language = page.lang || page.language || config.language; 增加许可协议新版已经支持许可协议，直接配置即可，参考官方文档。 增加标题自动计数diff:include/style/article.styl1234567+.article {counter-reset:section}+.article h2{counter-reset:sub-section}+.article h3{counter-reset:composite}+.article h4{counter-reset:detail}+.article h2:before{content:counter(section) &quot; &quot;;counter-increment:section}+.article h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section}+.article h4:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite} 默认显示目录新版支持直接配置，在_config.yml增加toc: true即可。 页面footer显示一组icon默认情况下一个icon对应一个链接，但例如 CC BY-NC-SA 4.0 需要四个图标一组。因此修改代码，使得配置 link.icon 可以是一个数组，效果可以参考页面底部。 diff:layout/common/footer.jsx123456789101112 const link = links[name]; return &lt;p class=&quot;control&quot;&gt; &lt;a class={`button is-transparent ${link.icon ? 'is-large' : ''}`} target=&quot;_blank&quot; rel=&quot;noopener&quot; title={name} href={link.url}&gt;- {link.icon ? &lt;i class={link.icon}&gt;&lt;/i&gt; : name}+ {link.icon ?+ (Array.isArray(link.icon) ?+ link.icon.map(i =&gt; [&lt;i className={i}&gt;&lt;/i&gt;, '\\u00A0']) :+ &lt;i className={link.icon}&gt;&lt;/i&gt;+ ) : name} &lt;/a&gt; &lt;/p&gt;; })} 忽略校验的schema diff:include/schema/common/footer.json1- &quot;$ref&quot;: &quot;/misc/poly_links.json&quot;, _config.yml 中配置如下 _config.yml123456789footer: links: CC BY-NC-SA 4.0: icon: - fab fa-creative-commons - fab fa-creative-commons-by - fab fa-creative-commons-nc - fab fa-creative-commons-sa url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 样式修改 logo 和 favicon用 Python 设计 Logo，并微调样式。 按钮背景颜色增加渐变diff:include/style/widget.styl123456789 .widget .menu-list li ul margin-right: 0+ a+ transition: background-color 0.3s ease-in-out .level margin-bottom: 0 card 增加浮动效果:hover 时增大阴影，并增加动画属性 ease-in-out。 diff:include/style/card.styl12345 .card overflow: visible border-radius: $card-radius+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) diff:source/js/animation.js123456 setTimeout(() =&gt; { $('body &gt; .navbar, body &gt; .section, body &gt; .footer').forEach(element =&gt; { element.style.opacity = '1';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }); diff:source/js/animation.js1234 element.style.transform = '';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }, i * 100); 修改tag的颜色diff:include/style/widget.styl1234567891011 .tags .tag:first-child- background: $primary- color: $primary-invert+ background: whitesmoke+ color: #4a4a4a .tag:last-child- background: $light-grey+ background: #e7e7e7 color: $white-invert 更新2020-12-04 基于 4.1.1 版本重新改动。2021-09-06 合并 4.4.0，官方也支持文章 licenses配置多个图标，不过目前还是自己实现的。 总结这里只列举了部分改动，详细的差异可以查看 diff。 本文会持续更新，保持跟最新的博客效果一致，希望能给你自定义主题一些帮助。 如果有其他想法或者意见，可以在下方留言。","link":"/2019/03/customize-icarus/"},{"title":"Java进阶 — 类加载机制","text":"类加载机制是 Java 技术体系中非常核心的部分，负责把 class 文件加载到 JVM。 类加载器可以说是 Java 语言的一项创新，它是早期 Java 语言能够快速流行的重要原因之一。类加载器最初是为了满足 Java Applet 的需求而设计出来的，在今天用在浏览器上的 Java Applet 技术基本上已经被淘汰，但类加载器却在类层次划分、OSGi、程序热部署、代码加密等领域大放异彩，成为 Java 技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。 ——《深入理解 Java 虚拟机》 开始之前先抛出五个问题，看看能否给出准确的回答 如何启动一个 Java 应用？JVM 启动的时候是如何查找类的？ 是先有的 Class 还是先有的 ClassLoader？JVM 启动的时候是如何处理 ClassLoader 的？ ClassLoader 的层次结构是什么样的？双亲委派模型是什么？contextClassLoader 是什么？ 类加载过程中会遇到哪些错误 Error 或者异常 Exception？NoClassDefFoundError 和 ClassNotFoundException 区别是什么？ 什么情况下需要自定义 ClassLoader？如何自定义 ClassLoader？ Java 应用启动无论是通过什么脚本启动还是在 IDE 里面直接执行，最终都是通过执行 java 命令。 IDEA 启动应用的第一行日志 mvn 命令，其实是个脚本 apache-maven-3.6.3/bin/mvn12345678910111213141516# ...# Provide a &quot;standardized&quot; way to retrieve the CLI args that will# work with both Windows and non-Windows executions.MAVEN_CMD_LINE_ARGS=&quot;$MAVEN_CONFIG $@&quot;export MAVEN_CMD_LINE_ARGSexec &quot;$JAVACMD&quot; \\ $MAVEN_OPTS \\ $MAVEN_DEBUG_OPTS \\ -classpath &quot;${CLASSWORLDS_JAR}&quot; \\ &quot;-Dclassworlds.conf=${MAVEN_HOME}/bin/m2.conf&quot; \\ &quot;-Dmaven.home=${MAVEN_HOME}&quot; \\ &quot;-Dlibrary.jansi.path=${MAVEN_HOME}/lib/jansi-native&quot; \\ &quot;-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}&quot; \\ ${CLASSWORLDS_LAUNCHER} &quot;$@&quot; 来看一下 java 命令的帮助 12345$ java -helpUsage: java [-options] class [args...] (to execute a class) or java [-options] -jar jarfile [args...] (to execute a jar file) 文档中对于 Java 启动时类查找的说明 https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html How the Java Launcher Finds Classes The Java launcher, java, initiates the Java virtual machine. The virtual machine searches for and loads classes in this order: Bootstrap classes - Classes that comprise the Java platform, including the classes in rt.jar and several other important jar files. Extension classes - Classes that use the Java Extension mechanism. These are bundled as .jar files located in the extensions directory. User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. div.inline-code-gray code { color: steelblue !important } How the Java Launcher Finds User Classes User classes are classes which build on the Java platform. To find user classes, the launcher refers to the user class path – a list of directories, JAR archives, and ZIP archives which contain class files.A class file has a subpath name that reflects the class’s fully-qualified name. For example, if the class com.mypackage.MyClass is stored under /myclasses, then /myclasses must be in the user class path and the full path to the class file must be /myclasses/com/mypackage/MyClass.class. If the class is stored in an archive named myclasses.jar, then myclasses.jar must be in the user class path, and the class file must be stored in the archive as com/mypackage/MyClass.class.The user class path is specified as a string, with a colon (:) separating the class path entries on Solaris, and a semi-colon (;) separating entries on Microsoft Windows systems. The java launcher puts the user class path string in the java.class.path system property. The possible sources of this value are: The default value, “.”, meaning that user class files are all the class files in the current directory (or under it, if in a package). The value of the CLASSPATH environment variable, which overrides the default value. The value of the -cp or -classpath command line option, which overrides both the default value and the CLASSPATH value. The JAR archive specified by the -jar option, which overrides all other values. If this option is used, all user classes must come from the specified archive. IDE 和 mavenIDE 会通过 maven 插件，解析项目模块，计算 classpath，最终通过 -classpath 影响启动，所以修改依赖的时候需要重新加载项目。 IDE 多模块的 classpath每个模块的 classpath 是独立计算的，在不同模块启动 main 方法的的时候 -classpath 参数是不同的，例如有两个模块 A B，A 依赖 B 和第三方 C.jar , B 依赖第三方 D.jar 1234A├── C.jar└── B └──D.jar 最终启动 A 中的 main 方法（会指向对应模块的 target/classes 目录） 1java -classpath ${项目}/A/target/classes:${项目}/B/target/classes:${仓库}/C.jar:${仓库}/D.jar ... 如果是启动 B 中的 main 方法（此时是找不到 A 中定义类的） 1java -classpath ${项目}/B/target/classes:${仓库}/D.jar ... Spring 包扫描与 classpath 的关系Spring 只能扫描类加载能加载到的类，可以简单认为就是只能加载 classpath 下的类。 Object Class ClassLoader (java.lang.*)任何对象都是一个类的实例，那么 java.lang.String.class 是一个对象吗？（java.lang.Class extend java.lang.Object） Class 实例是通过 ClassLoader 的实例加载的，但 ClassLoader 实例本身也是一个对象，所以也会有 Class，下面这几个值是什么关系？ 1234Class.classClassLoader.classClass.class.getClassLoader()ClassLoader.class.getClassLoader() 从 JDK 源码看类的加载SystemDictionary 管理了所有加载的类 hotspot/src/share/vm/classfile/systemDictionary.hppsystemDictionary.hpp12345678class SystemDictionary : AllStatic { //... // Hashtable holding loaded classes. static Dictionary* _dictionary; //...} 而 Dictionary 就是一个 Hashtable hotspot/src/share/vm/classfile/dictionary.hppdictionary.hpp123class Dictionary : public TwoOopHashtable&lt;Klass*, mtClass&gt; { //...} 再来看下 Klass hotspot/src/share/vm/oops/klass.hppklass.hpp123456789// A Klass provides:// 1: language level class object (method dictionary etc.)// 2: provide vm dispatch behavior for the object// Both functions are combined into one C++ class.// ...class Klass : public Metadata { // ...} hotspot/src/share/vm/oops/instanceKlass.hppinstanceKlass.hpp123456789101112131415161718192021222324252627282930313233343536373839404142// An InstanceKlass is the VM level representation of a Java class.// It contains all information needed for at class at execution runtime.// InstanceKlass layout:// [C++ vtbl pointer ] Klass// [subtype cache ] Klass// [instance size ] Klass// [java mirror ] Klass// [super ] Klass// [access_flags ] Klass// [name ] Klass// [first subklass ] Klass// [next sibling ] Klass// [array klasses ]// [methods ]// [local interfaces ]// [transitive interfaces ]// [fields ]// [constants ]// [class loader ]// [source file name ]// [inner classes ]// [static field size ]// [nonstatic field size ]// [static oop fields size ]// [nonstatic oop maps size ]// [has finalize method ]// [deoptimization mark bit ]// [initialization state ]// [initializing thread ]// [Java vtable length ]// [oop map cache (stack maps) ]// [EMBEDDED Java vtable ] size in words = vtable_len// [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size// The embedded nonstatic oop-map blocks are short pairs (offset, length)// indicating where oops are located in instances of this klass.// [EMBEDDED implementor of the interface] only exist for interface// [EMBEDDED host klass ] only exist for an anonymous class (JSR 292 enabled)class InstanceKlass: public Klass { // ...} 在 hotspot 代码里面 Klass 是类的底层实现，类加载最终的结果就是创建一个 Klass （或其子类）对象，而 SystemDictionary 管理了所有的加载的类。 Java 虚拟机启动来看一下 JVM 启动的时候跟 ClassLoader 相关的主要流程，从 main 方法到 java main 方法 12345678910111213141516171819main (jdk/src/share/bin/main.c)-&gt; JLI_Launch (jdk/src/share/bin/java.c) -&gt; LoadJavaVM (jdk/src/share/bin/java.c) // 加载动态库找到hotspot实现 -&gt; JVMInit (jdk/src/share/bin/java.c) -&gt; ContinueInNewThread (jdk/src/share/bin/java.c) -&gt; ContinueInNewThread0 (jdk/src/solaris/bin/java_md_solinux.c) -&gt; JavaMain (jdk/src/share/bin/java.c) -&gt; InitializeJVM (jdk/src/share/bin/java.c) -&gt; JNI_CreateJavaVM (hotspot/src/share/vm/prims/jni.cpp) -&gt; Threads::create_vm (hotspot/src/share/vm/runtime/thread.cpp) -&gt; init_globals (hotspot/src/share/vm/runtime/init.cpp) -&gt; universe2_init (hotspot/src/share/vm/runtime/universe.cpp) -&gt; Universe::genesis (hotspot/src/share/vm/runtime/universe.cpp) -&gt; SystemDictionary::initialize (hotspot/src/share/vm/classfile/systemDictionary.cpp) -&gt; SystemDictionary::initialize_preloaded_classes (hotspot/src/share/classfile/systemDictionary.cpp) -&gt; SystemDictionary::compute_java_system_loader (hotspot/src/share/classfile/systemDictionary.cpp) -&gt; LoadMainClass (jdk/src/share/bin/java.c) // 加载 MainClass -&gt; GetStaticMethodID (jdk/src/share/bin/java.c) // 找 main 方法 -&gt; CallStaticVoidMethod (jdk/src/share/bin/java.c) // 调用 main 方法 hotspot/src/share/vm/classfile/systemDictionary.hppsystemDictionary.hpp12345678910111213141516171819202122232425262728293031323334#define WK_KLASSES_DO(do_klass) \\ /* well-known classes */ \\ do_klass(Object_klass, java_lang_Object, Pre ) \\ do_klass(String_klass, java_lang_String, Pre ) \\ do_klass(Class_klass, java_lang_Class, Pre ) \\ do_klass(Cloneable_klass, java_lang_Cloneable, Pre ) \\ do_klass(ClassLoader_klass, java_lang_ClassLoader, Pre ) \\ do_klass(Serializable_klass, java_io_Serializable, Pre ) \\ do_klass(System_klass, java_lang_System, Pre ) \\ do_klass(Throwable_klass, java_lang_Throwable, Pre ) \\ do_klass(Error_klass, java_lang_Error, Pre ) \\ do_klass(ThreadDeath_klass, java_lang_ThreadDeath, Pre ) \\ do_klass(Exception_klass, java_lang_Exception, Pre ) \\ do_klass(RuntimeException_klass, java_lang_RuntimeException, Pre ) \\ do_klass(SecurityManager_klass, java_lang_SecurityManager, Pre ) \\ do_klass(ProtectionDomain_klass, java_security_ProtectionDomain, Pre ) \\ do_klass(AccessControlContext_klass, java_security_AccessControlContext, Pre ) \\ do_klass(ClassNotFoundException_klass, java_lang_ClassNotFoundException, Pre ) \\ do_klass(NoClassDefFoundError_klass, java_lang_NoClassDefFoundError, Pre ) \\ do_klass(LinkageError_klass, java_lang_LinkageError, Pre ) \\ do_klass(ClassCastException_klass, java_lang_ClassCastException, Pre ) \\ do_klass(ArrayStoreException_klass, java_lang_ArrayStoreException, Pre ) \\ do_klass(VirtualMachineError_klass, java_lang_VirtualMachineError, Pre ) \\ do_klass(OutOfMemoryError_klass, java_lang_OutOfMemoryError, Pre ) \\ do_klass(StackOverflowError_klass, java_lang_StackOverflowError, Pre ) \\ do_klass(IllegalMonitorStateException_klass, java_lang_IllegalMonitorStateException, Pre ) \\ do_klass(Reference_klass, java_lang_ref_Reference, Pre ) \\ \\ /* Preload ref klasses and set reference types */ \\ do_klass(SoftReference_klass, java_lang_ref_SoftReference, Pre ) \\ do_klass(WeakReference_klass, java_lang_ref_WeakReference, Pre ) \\ do_klass(FinalReference_klass, java_lang_ref_FinalReference, Pre ) \\ do_klass(PhantomReference_klass, java_lang_ref_PhantomReference, Pre ) \\ // ... hotspot/src/share/vm/classfile/systemDictionary.cppsystemDictionary.cpp123456789101112void SystemDictionary::initialize_preloaded_classes(TRAPS) { // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK); // ... Universe::initialize_basic_type_mirrors(CHECK); // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);. // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK); // ... initialize_wk_klasses_until(WKID_LIMIT, scan, CHECK);} SystemClassLoader除了 Bootstrap ClassLoader 之外的类加载器都是在 Java 代码里面定义的，系统类加载器 ClassLoader.getSystemClassLoader() java.lang.ClassLoader123456789101112131415161718192021222324252627282930313233343536public abstract class ClassLoader { // ... // The class loader for the system // @GuardedBy(&quot;ClassLoader.class&quot;) private static ClassLoader scl; // Set to true once the system class loader has been set // @GuardedBy(&quot;ClassLoader.class&quot;) private static boolean sclSet; // ... @CallerSensitive public static ClassLoader getSystemClassLoader() { initSystemClassLoader(); if (scl == null) { return null; } SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkClassLoaderPermission(scl, Reflection.getCallerClass()); } return scl; } private static synchronized void initSystemClassLoader() { if (!sclSet) { if (scl != null) throw new IllegalStateException(&quot;recursive invocation&quot;); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); // ... sclSet = true; } }} sun.misc.Launcher12345678910111213141516171819202122232425public class Launcher { // ... public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError(&quot;Could not create extension class loader&quot;, e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError(&quot;Could not create application class loader&quot;, e); } // Also set the context class loader for the primordial thread. Thread.currentThread().setContextClassLoader(loader); // ... }} 同时可以看到 AppClassLoader 的 parent 是 ExtClassLoader，同时 SystemClassLoader 也是在 JVM 初始化的时候进行初始化的 hotspot/src/share/vm/classfile/systemDictionary.cppsystemDictionary.cpp1234567891011void SystemDictionary::compute_java_system_loader(TRAPS) { KlassHandle system_klass(THREAD, WK_KLASS(ClassLoader_klass)); JavaValue result(T_OBJECT); JavaCalls::call_static(&amp;result, KlassHandle(THREAD, WK_KLASS(ClassLoader_klass)), vmSymbols::getSystemClassLoader_name(), vmSymbols::void_classloader_signature(), CHECK); _java_system_loader = (oop)result.get_jobject();} MainClass 的加载jdk/src/share/bin/java.cjava.c12345678910111213141516171819202122232425262728int JNICALL JavaMain(void * _args){ // ... mainClass = LoadMainClass(env, mode, what); // ... mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); // ... /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); // ...}static jclass LoadMainClass(JNIEnv *env, int mode, char *name){ // ... jclass cls = GetLauncherHelperClass(env); // ... // sun.launcher.LauncherHelper#checkAndLoadMain NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;checkAndLoadMain&quot;, &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;)); str = NewPlatformString(env, name); result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, USE_STDERR, mode, str); // ... return (jclass)result;} sun.launcher.LauncherHelper123456789101112public enum LauncherHelper { private static final ClassLoader scloader = ClassLoader.getSystemClassLoader(); public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr, int mode, String what) { // ... mainClass = scloader.loadClass(cn); // ... return mainClass; }} 因此 MainClass 是由 ClassLoader.getSystemClassLoader() 加载的 一些结论 从 hotspot 的角度来讲，所有类都是通过 Klass 对象来描述的 类是一个抽象的概念 Object.class != Object 类，可以说 Object.class 也是一个对象，是用来表示底层（C++）Klass 的一个对象 一定是先有类，才有对象。一切都是对象，都继承自java.lang.Object（除了基本类型） 在 JVM 加载的过程中，会预先初始化一些 Klass 对象（well known classes），来描述具体的类 最早加载的几个类（按照顺序）java.lang.Object , java.lang.String , java.lang.Class , 9 个基本类型（包含 Void.TYPE）, java.lang.Cloneable , java.lang.ClassLoader 这些类是预加载，不需要有一个 java.lang.ClassLoader 的实例来加载，这个时候 JVM 都没有完全初始化 默认会有三个 ClassLoader，Bootstrap ClassLoader 是 C++实现的 Class.class.getClassLoader() == null （Bootstrap ClassLoader 在 Java 层面就是 null） 主类的 ClassLoader 就是 ClassLoader.getSystemClassLoader() Bootstrap ClassLoader 的存在是一个比较自然的事情，不需要死记硬背。 下面语句分别输出什么？ 12345678910public class Test { public static void main(String[] args) { System.out.println(Test.class.getClassLoader()); System.out.println(javax.sql.DataSource.class.getClassLoader()); System.out.println(String.class.getClassLoader()); System.out.println(ClassLoader.getSystemClassLoader()); System.out.println(ClassLoader.getSystemClassLoader().getParent()); System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); }} 可以自己试一下，不同版本会有差异。 类的加载、链接、初始化通过类的全名（binary name）获取二进制流加载到 JVM，并生成一个 java.lang.Class 对象表示这个类。 图片来源于网络 来看一下 Java 虚拟机规范关于类加载的描述 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html How the Java Launcher Finds Classes The Java launcher, java, initiates the Java virtual machine. The virtual machine searches for and loads classes in this order: Bootstrap classes - Classes that comprise the Java platform, including the classes in rt.jar and several other important jar files. Extension classes - Classes that use the Java Extension mechanism. These are bundled as .jar files located in the extensions directory. User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. 现在我们知道，系统启动的时候，一共有三个 ClassLoader Bootstrap ClassLoader (C++ null) ExtClassLoader (SystemDictionary::compute_java_system_loader 时初始化) AppClassLoader (SystemDictionary::compute_java_system_loader 时初始化) 后续 ExtClassLoader 指 sun.misc.Launcher$ExtClassLoader 一个的实例，AppClassLoader 指 sun.misc.Launcher$AppClassLoader 的一个的实例 类型判断两个类型是否相等，是指全名（binary name）相等且是同一个类加载器完成加载的。包括兼容性判断 java.lang.Class.isAssignableFrom java.lang.Class.isInstance java.lang.Class.equals instanceof 关键字 类型转换 那么不同类加载器在加载同一个类的时候，应该如何处理 123456789101112131415public class Test { public static void main(String[] args) throws ClassNotFoundException { String name = &quot;java.lang.Object&quot;; Class&lt;?&gt; objectClass1 = Object.class; Class&lt;?&gt; objectClass2 = ClassLoader.getSystemClassLoader().loadClass(name); Class&lt;?&gt; objectClass3 = new URLClassLoader(new URL[0]).loadClass(name); objectClass2.isAssignableFrom(Test.class); objectClass3.isInstance(new Test()); objectClass1.getClassLoader(); // null objectClass2.getClassLoader(); // ? objectClass3.getClassLoader(); // ? }} 如果每个 ClassLoader 都去加载一遍 java.lang.Object 那么不同类加载加载的 Class 是不是相等的？如果不想等对象就没有办法相互转换，那么整个程序就会表现的很奇怪，从这个角度上讲 AppClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 AppClassLoader 去加载 Extension classes 也应该是由 ExtClassLoader 加载的 ExtClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 这就是一个委托（delegation）的模型。 双亲委派来看一下 ClassLoader 是如何加载一个类的https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance. 这个一般就称为双亲委派模型（Parent Delegation Model ）。 这个名词的翻译不好，“双”这个字不是很准确 java.lang.ClassLoader12345678910111213public abstract class ClassLoader { private static native void registerNatives(); static { registerNatives(); } // The parent class loader for delegation // Note: VM hardcoded the offset of this field, thus all new fields // must be added *after* it. private final ClassLoader parent; // ...} 其中 AppClassLoader 的 parent 是 ExtClassLoader，ExtClassLoader 的 parent 是 Bootstrap ClassLoader（null），这个跟之前的理解是一致的 AppClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 AppClassLoader 去加载 Extension classes 也应该是由 ExtClassLoader 加载的 ExtClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 加载类对应的方法https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#loadClass-java.lang.String-boolean- java.lang.ClassLoader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class ClassLoader { // ... protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. // ... c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } // ... /** * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;. * This method should be overridden by class loader implementations that * follow the delegation model for loading classes, and will be invoked by * the {@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;} method after checking the * parent class loader for the requested class. The default implementation * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;. */ protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } // ...} 图片来源于网络 从上面的代码来看，双亲委派的实现时非常简单的。那为什么需要双亲委派？总感觉这个问题不是很好回答，因为从上面的分析来看，如果是这个 ClassLoader 的模型，那么双亲委派就是比较自然的方案 保证类的唯一性 避免重复加载 安全，核心类不会被篡改（比如 -classpath 中包含 java.lang.Object，但委托给 Bootstrap ClassLoader 之后就只能加载默认的类） 为了保证安全性，java. 开头的类是不能去定义的（例如在 -classpath 中包含 java.lang.Object2） java.lang.ClassLoader1234567891011private ProtectionDomain preDefineClass(String name, ProtectionDomain pd){ // ... // relies on the fact that spoofing is impossible if a class has a name // of the form &quot;java.*&quot; if ((name != null) &amp;&amp; name.startsWith(&quot;java.&quot;)) { throw new SecurityException(&quot;Prohibited package name: &quot; + name.substring(0, name.lastIndexOf('.'))); } // ...} 这里有对上述过程更详细的解释https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc5.html SPI 与 ContextClassLoader我们来看一下 SPI 12345678public class Test { public static void main(String[] args) { Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mysql&quot;, &quot;root&quot;, &quot;123456&quot;); System.out.println(conn.getClass() == com.mysql.cj.jdbc.ConnectionImpl.class); System.out.println(com.mysql.cj.jdbc.ConnectionImpl.class.getClassLoader()); System.out.println(DriverManager.class.getClassLoader()); }} 可能这里看上去没有什么问题，但是 DriverManager 是 Bootstrap ClassLoader 加载的，最终 ConnectionImpl 是应用自己的 classpath 下，是 AppClassLoader 加载的。 那能不能写死 SPI 就用 java.lang.ClassLoader.getSystemClassLoader() 来加载呢？ 来看一下 DriverManager 是如何加载具体 Driver 实现的 java.sql.DriverManager12345678910111213141516public class DriverManager { // ... static { loadInitialDrivers(); } // ... private static void loadInitialDrivers() { // ... // SPI ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); // ... }} java.util.ServiceLoader12345678public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt; { // ... public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } // ...} 解决这个问题是通过线程上下文类加载器 Thread.currentThread().getContextClassLoader() ，每个线程绑定一个类加载器 12345Thread.currentThread().setContextClassLoader(classloader1)ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Thread.currentThread().setContextClassLoader(classloader2)ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); ContextClassLoader 并不是一个优雅的设计，不过一般在代码中很少需要关注。主要使用场景是各种框架，框架利用上下文加载器加载对应的资源或者类。 双亲委派机制的破坏双亲委派的核心就是 parent 属性和 loadClass 方法 java.lang.ClassLoader1protected Class&lt;?&gt; loadClass(String name, boolean resolve) protected 说明这个方法是可以覆盖的，因此双亲委派不是强制的，肯定有一些场景是可以改写这个逻辑的。 一般认为 SPI 是破坏了双亲委派机制的（委派给另外一个上下文 ClassLoader 而不 parent），此外就是覆盖 loadClass 方法破坏双亲委派的机制，具体的使用场景后面会讲。 类的初始化时机https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html Initialization of a class or interface consists of executing its class or interface initialization method (§2.9). A class or interface C may be initialized only as a result of: The execution of any one of the Java Virtual Machine instructions new, getstatic, putstatic, or invokestatic that references C (§new, §getstatic, §putstatic, §invokestatic). These instructions reference a class or interface directly or indirectly through either a field reference or a method reference.Upon execution of a new instruction, the referenced class is initialized if it has not been initialized already.Upon execution of a getstatic, putstatic, or invokestatic instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already. The first invocation of a java.lang.invoke.MethodHandle instance which was the result of method handle resolution (§5.4.3.5) for a method handle of kind 2 (REF_getStatic), 4 (REF_putStatic), 6 (REF_invokeStatic), or 8 (REF_newInvokeSpecial).This implies that the class of a bootstrap method is initialized when the bootstrap method is invoked for an invokedynamic instruction (§invokedynamic), as part of the continuing resolution of the call site specifier. Invocation of certain reflective methods in the class library (§2.12), for example, in class Class or in package java.lang.reflect. If C is a class, the initialization of one of its subclasses. If C is an interface that declares a non-abstract, non-static method, the initialization of a class that implements C directly or indirectly. If C is a class, its designation as the initial class at Java Virtual Machine startup (§5.2). 有且只有上述 6 种情况（且这个类没有被加载）会去加载一个类，简单来说 new 读取/修改静态变量（排除在常量池的）调用静态方法 动态语言支持 java.lang.invoke.MethodHandle 相关 class library 中的一些方法，例如 Class 和 ClassLoader 的部分方法、反射（java.lang.reflect）等 初始化类的某个子类的时候 初始化包含默认方法接口的某个实现类的 Java 启动类（main Class） 其中 4 和 5 可以统一成一个递归的描述，如果要初始化一个类，需要先初始化父类和包含 default 方法的接口。6 在实现的时候其实属于 3 的，是通过java.lang.ClassLoader.loadClass加载的（sun.launcher.LauncherHelper）。 类加载的相关异常类加载过程，需要进行验证，比如文件格式、JAVA 版本、final 约束、可访问性约束等，具体细节就不赘述了 同时还有一个有一个非常重要的异常 12345678910try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); }} catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader} 在双亲委派的过程中 parent 如果加载不了某个类，需要抛出 java.lang.ClassNotFoundException（这里只 catch 了这个异常）。 public class ClassNotFoundException extends ReflectiveOperationException Thrown when an application tries to load in a class through its string name using: The forName method in class Class. The findSystemClass method in class ClassLoader . The loadClass method in class ClassLoader.but no definition for the class with the specified name could be found. public class NoClassDefFoundError extends LinkageError Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found. java.lang.NoClassDefFoundError 是一个 Error，发生在实例化一个类的时候（类已经找到了），一般情况是这个类依赖的某些定义不存在，一般会出现在 jar 包的版本不兼容上。 类的卸载满足如下条件，则类会被卸载 该类的所有实例（包含子类的实例）都被回收 该类的 ClassLoader 不存在任何引用 该类的 Class 对象不存在任何引用（包括相关的 Method Field 等，无法通过反射访问） 注意默认的三个类加载对应的类是不会被卸载的（ClassLoader 会一直被引用）。 自定义 ClassLoader如何自定义 ClassLoader一般是继承 java.net.URLClassLoader 或者直接继承 java.lang.ClassLoader，然后覆盖 findClass 或 loadClass 方法 覆盖 findClass这种修改一般不破坏双亲委派，会修改查找类的逻辑，实现某些动态的逻辑。可以实现但不限于以下的逻辑 从网络获取 从特定目录获取 特定目录结构的压缩包 War 包 WEB-INF SpringBoot FatJar 对二进制流做预处理，例如解密或验证签名 内存直接定义 Class 文件（配合字节码的库）（动态代理） 实现热加载 类似 JSP 的技术 … 覆盖 loadClass一般是修改类加载的层级结构，可以实现但不限于以下的逻辑 模块化 自定义某种类隔离的机制，例如 Tomcat … 当然上面两种也可以进行组合 应用场景SpringBootspring boot 应用打包之后可以直接通过 java -jar 命令启动 。 实现原理是 spring-boot-maven-plugin 在构建（repackage）的时候，会通过 org.springframework.boot.maven.RepackageMojo 打包成特定结构的 Jar 包https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.layers org.springframework.boot.loader.tools.Layouts.Jar12345678910111213141516171819202122232425262728293031/** * Executable JAR layout. */public static class Jar implements RepackagingLayout { @Override public String getLauncherClassName() { return &quot;org.springframework.boot.loader.JarLauncher&quot;; } @Override public String getLibraryDestination(String libraryName, LibraryScope scope) { return &quot;BOOT-INF/lib/&quot;; } @Override public String getClassesLocation() { return &quot;&quot;; } @Override public String getRepackagedClassesLocation() { return &quot;BOOT-INF/classes/&quot;; } @Override public boolean isExecutable() { return true; } // ...} 可以找一个 spring boot 的 Fat Jar 解压看一下看看 1234567891011121314151617181920212223242526.├── BOOT-INF│ ├── classes│ │ ├── application.properties│ │ └── com│ │ └── example│ │ └── demo│ │ └── DemoApplication.class│ ├── classpath.idx│ ├── layers.idx│ └── lib│ ├── ...│ ├── spring-boot-2.5.4.jar│ ├── spring-boot-autoconfigure-2.5.4.jar│ ├── spring-context-5.3.9.jar│ └── spring-core-5.3.9.jar├── META-INF│ └── MANIFEST.MF└── org └── springframework └── boot └── loader ├── JarLauncher.class ├── LaunchedURLClassLoader.class ├── Launcher.class ├── ... java -jar 命令会在 MANIFEST.MF 里面找 Main-Class 来运行，看下 META-INF/MANIFEST.MF 文件内容 META-INF/MANIFEST.MF123456789101112Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: demoImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.example.demo.DemoApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher 那么是如何启动的呢？ org.springframework.boot.loader.JarLauncher1234567891011121314151617181920212223242526public class JarLauncher extends ExecutableArchiveLauncher { static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;; static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;; public JarLauncher() { } protected JarLauncher(Archive archive) { super(archive); } @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } public static void main(String[] args) throws Exception { new JarLauncher().launch(args); } // ...} org.springframework.boot.loader.ExecutableArchiveLauncher123456789101112131415161718192021222324252627282930public abstract class ExecutableArchiveLauncher extends Launcher { // ... @Override protected String getMainClass() throws Exception { Manifest manifest = this.archive.getManifest(); String mainClass = null; if (manifest != null) { mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;); } if (mainClass == null) { throw new IllegalStateException(&quot;No 'Start-Class' manifest entry specified in &quot; + this); } return mainClass; } @Override protected List&lt;Archive&gt; getClassPathArchives() throws Exception { List&lt;Archive&gt; archives = new ArrayList&lt;Archive&gt;(this.archive.getNestedArchives(new EntryFilter() { @Override public boolean matches(Entry entry) { return isNestedArchive(entry); } })); postProcessClassPathArchives(archives); return archives; } // ...} org.springframework.boot.loader.Launcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class Launcher { /** * Launch the application. This method is the initial entry point that should be * called by a subclass {@code public static void main(String[] args)} method. * @param args the incoming arguments * @throws Exception if the application fails to launch */ protected void launch(String[] args) throws Exception { JarFile.registerUrlProtocolHandler(); ClassLoader classLoader = createClassLoader(getClassPathArchives()); launch(args, getMainClass(), classLoader); } /** * Create a classloader for the specified archives. * @param archives the archives * @return the classloader * @throws Exception if the classloader cannot be created */ protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception { List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(archives.size()); for (Archive archive : archives) { urls.add(archive.getUrl()); } return createClassLoader(urls.toArray(new URL[urls.size()])); } /** * Create a classloader for the specified URLs. * @param urls the URLs * @return the classloader * @throws Exception if the classloader cannot be created */ protected ClassLoader createClassLoader(URL[] urls) throws Exception { return new LaunchedURLClassLoader(urls, getClass().getClassLoader()); } /** * Launch the application given the archive file and a fully configured classloader. * @param args the incoming arguments * @param mainClass the main class to run * @param classLoader the classloader * @throws Exception if the launch fails */ protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception { Thread.currentThread().setContextClassLoader(classLoader); createMainMethodRunner(mainClass, args, classLoader).run(); } // ...} 因为是 Fat Jar 的模式（Jar in Jar），因此需要自己实现 LaunchedURLClassLoader 来定制类的查找逻辑。 TomcatTomcat 可以同时加载多个 web 应用，并且可以热加载，支持动态加载或者卸载 web 应用。大概的实现思路 Tomcat 自身的代码会有一个 ClassLoader Tomcat 为每个 Web 应用创建一个 org.apache.catalina.loader.WebappClassLoader 加载 Web 应用自己的类，且 parent 会指向 Tomcat 自身的类加载器 WebappClassLoader 加载的时候 会先通过 javaseClassLoader 加载，默认为 ClassLoader.getSystemClassLoader().getParent() 部分类会通过 parent 来进行加载，这样应用可以共享一些类的定义（例如 javax.servlet.* 和 org.apache.tomcat.*） 之后会加载 Web 应用目录下的类，因此可以实现不同应用之间的类是隔离的 上述过程会破坏双亲委派的模型。来看一下 Tomcat 的目录结构，webapps 目录下包含了所有的 Web 应用 12345678910111213141516171819202122.├── bin│ ├── ...│ ├── shutdown.sh│ └── startup.sh├── conf│ ├── ...│ ├── server.xml│ └── web.xml├── lib│ ├── ...│ ├── servlet-api.jar│ ├── tomcat-api.jar│ └── tomcat-websocket.jar├── logs├── webapps│ ├── ROOT│ ├── docs│ ├── examples│ ├── host-manager│ └── manager└── work Tomcat 文档关于 WebappClassLoaderBase.loadClass 的描述 https://tomcat.apache.org/tomcat-8.5-doc/api/org/apache/catalina/loader/WebappClassLoaderBase.html org.apache.catalina.loader.WebappClassLoaderBase12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class WebappClassLoaderBase extends URLClassLoader implements ... { // ... @Override public Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // ... // (0) Check our previously loaded local class cache // ... // (0.1) Check our previously loaded class cache // ... // 之前会判断是否已经加载过 // javaseLoader 默认就是 java.lang.ClassLoader.getSystemClassLoader().getParent() ClassLoader javaseLoader = getJavaseClassLoader(); boolean tryLoadingFromJavaseLoader; // 判断是否应该用 javaseLoader 加载 // ... // 通过 javaseLoader 加载 if (tryLoadingFromJavaseLoader) { try { clazz = javaseLoader.loadClass(name); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } } boolean delegateLoad = delegate || filter(name, true); // (1) Delegate to our parent if requested if (delegateLoad) { try { clazz = Class.forName(name, false, parent); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { // Ignore } } // (2) Search local repositories try { clazz = findClass(name); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } // (3) Delegate to parent unconditionally if (!delegateLoad) { try { clazz = Class.forName(name, false, parent); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } } throw new ClassNotFoundException(name); } protected boolean filter(String name, boolean isClassName) { // ... if (name.startsWith(&quot;javax&quot;)) { /* 5 == length(&quot;javax&quot;) */ if (name.length() == 5) { return false; } ch = name.charAt(5); if (isClassName &amp;&amp; ch == '.') { /* 6 == length(&quot;javax.&quot;) */ if (name.startsWith(&quot;servlet.jsp.jstl.&quot;, 6)) { return false; } if (name.startsWith(&quot;el.&quot;, 6) || name.startsWith(&quot;servlet.&quot;, 6) || name.startsWith(&quot;websocket.&quot;, 6) || name.startsWith(&quot;security.auth.message.&quot;, 6)) { return true; } } // ... } // ... }} Tomcat ClassLoader 的层次结构 图片来源于网络 其他动态语言，例如 groovy.lang.GroovyClassLoader依赖冲突隔离 https://www.zhihu.com/question/46719811/answer/1739289578 。OSGI 模块化，后来 Java 标准也引入了的模块化。热加载也可以用多个 ClassLoader 来处理（IDEA 重新加载类，不是通过 ClassLoader 实现的）。 ClassLoader 问题排查思路在遇到 ClassLoader 相关问题的时候，可以试试如下的思路（一般在有多个 ClassLoader 的时候） object.getClass().getClassLoader() / clazz.getClassLoader() 查看某个类的 ClassLoader，判断是否符合预期 Thread.currentThread().getContextClassLoader() 获取当前线程上下文 ClassLoader，判断是否符合预期 在遇到类加载相关错误，要能想到可能是 ClassLoader 不对 在使用框架的时候，如果遇到类加载相关错误，要想到可能是 ContextClassLoader 不对 object.getClass().getProtectionDomain().getCodeSource() / clazz.getProtectionDomain().getCodeSource() 可以查看某个类加载的路径（如果两个 Jar 包都有相同的类，可以看到最终是加载了哪个 Jar 包的类），判断是否符合预期 能通过 arthas 类和类加载相关的命令（sc，classloader，jad 等）来排查问题 在修改 contextClassLoader 的时候，要注意恢复上下文，可以参考如下代码 12345678ClassLoader classLoader;ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();try { Thread.currentThread().setContextClassLoader(classLoader); // ...} finally { Thread.currentThread().setContextClassLoader(contextClassLoader);} 补充：oop klass 模型上面提到，在 hotspot 代码里面 Klass 是类的底层实现，类加载最终的结果就是创建一个 Klass 对象，oop 是描述对象各种信息的指针，oop klass 模型是 JVM（hotspot）内非常核心的模型。 hotspot/src/share/vm/oops/klass.hppklass.hpp12345678// A Klass provides:// 1: language level class object (method dictionary etc.)// 2: provide vm dispatch behavior for the object// Both functions are combined into one C++ class.// ...class Klass : public Metadata { // ...} 图片来源于网络 在 C++层面有多个不同的类来描述这个体系，oop klass 模型这部分内容有兴趣可以自行搜索。 基本类型int.class 和 java.lang.Integer.class 是不同的，int.class == java.lang.Integer.TYPE。基本类型的值本质上来说不是 oop（也没有类型指针），所以 int.class 更像是 JVM 类型系统的一个特例（create_basic_type_mirror 从名字也能看出来），这些类型也是在 JVM 初始化过程中进行加载的（SystemDictionary::initialize_preloaded_classes）。 hotspot/src/share/vm/memory/universe.cppuniverse.cpp12345678910111213141516171819202122232425262728293031void Universe::initialize_basic_type_mirrors(TRAPS) { assert(_int_mirror==NULL, &quot;basic type mirrors already initialized&quot;); _int_mirror = java_lang_Class::create_basic_type_mirror(&quot;int&quot;, T_INT, CHECK); _float_mirror = java_lang_Class::create_basic_type_mirror(&quot;float&quot;, T_FLOAT, CHECK); _double_mirror = java_lang_Class::create_basic_type_mirror(&quot;double&quot;, T_DOUBLE, CHECK); _byte_mirror = java_lang_Class::create_basic_type_mirror(&quot;byte&quot;, T_BYTE, CHECK); _bool_mirror = java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK); _char_mirror = java_lang_Class::create_basic_type_mirror(&quot;char&quot;, T_CHAR, CHECK); _long_mirror = java_lang_Class::create_basic_type_mirror(&quot;long&quot;, T_LONG, CHECK); _short_mirror = java_lang_Class::create_basic_type_mirror(&quot;short&quot;, T_SHORT, CHECK); _void_mirror = java_lang_Class::create_basic_type_mirror(&quot;void&quot;, T_VOID, CHECK); _mirrors[T_INT] = _int_mirror; _mirrors[T_FLOAT] = _float_mirror; _mirrors[T_DOUBLE] = _double_mirror; _mirrors[T_BYTE] = _byte_mirror; _mirrors[T_BOOLEAN] = _bool_mirror; _mirrors[T_CHAR] = _char_mirror; _mirrors[T_LONG] = _long_mirror; _mirrors[T_SHORT] = _short_mirror; _mirrors[T_VOID] = _void_mirror;} 数组类型需要注意的是数组是 JVM 内部直接生成的，是一个特殊的类型（ArrayKlass）。在定义 SomeClass[] array = new SomeClass[1] 时并不会导致 SomeClass 类的初始化。数组也是 JVM 类型系统的特例。 补充：Java 标准模块化（Java 9+）在引入模块化之后，整个类加载机制会有一些变化，后面会单独写一遍文章来讲解。 参考https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.htmlhttps://hg.openjdk.java.net/jdk8https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.htmlhttps://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc5.html《深入理解 Java 虚拟机》https://www.cnblogs.com/mazhimazhi/","link":"/2021/09/java-classloader/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"classloader","slug":"classloader","link":"/tags/classloader/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"icarus","slug":"hexo/icarus","link":"/categories/hexo/icarus/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"ubuntu","slug":"linux/ubuntu","link":"/categories/linux/ubuntu/"},{"name":"matplotlib","slug":"python/matplotlib","link":"/categories/python/matplotlib/"}]}