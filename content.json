{"pages":[{"title":"About","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/hello-world/"},{"title":"Icarus 主题自定义（基于2.x）","text":"本文是基于icarus 2.x的版本，icarus从3.0开始使用jsx重写了，查看最新版本。 本博客所选取的主题是 Icarus ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 diff，这里记录一些主要的改动。 注: 可以通过变量 page.layout 来判断当前页面类型，'post' 表示当前是文章页面，具体可参考 hexo 文档。 布局文章页面两栏布局主题默认是三栏布局，并且显示了很多的 widget ，但在阅读文章时显得有些拥挤。因此在文章页面，修改为两栏布局，并显示特定的 widget。 diff:includes/helpers/layout.js12345678910 const widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ if (this.page.layout !== 'post') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ }+ if (position === 'left') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));+ } else {+ return []+ } 可以参考上述代码，即可实现不同页面不同 widget。 但两栏整体宽度跟三栏不同。因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 diff:layout/common/widget.ejs123456 &lt;% function side_column_class() { switch (column_count()) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: diff:layout/layout.ejs12345678910-&lt;body class=&quot;is-&lt;%= column_count() %&gt;-column&quot;&gt;+&lt;body class=&quot;is-3-column&quot;&gt; &lt;%- partial('common/navbar', { page }) %&gt; &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2:- return 'is-8-tablet is-8-desktop is-8-widescreen';+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 并修改在不同屏幕小大下的宽度 diff:source/css/style.styl12345678910111213 .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap+ .is-3-column .container+ max-width: screen-widescreen - gap+ width: screen-widescreen - gap @media screen and (min-width: screen-fullhd)+ .is-3-column .container+ max-width: screen-fullhd - 2 * gap+ width: screen-fullhd - 2 * gap .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon。 diff:layout/common/article.ejs1234567891011121314151617 &lt;div class=&quot;card-content article &lt;%= post.hasOwnProperty('direction') ? post.direction : '' %&gt;&quot;&gt;+ &lt;h1 class=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;+ &lt;% if (index) { %&gt;+ &lt;a class=&quot;has-link-black-ter&quot; href=&quot;&lt;%- url_for(post.link ? post.link : post.path) %&gt;&quot;&gt;&lt;i class=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;&lt;%= post.title %&gt;&lt;/a&gt;+ &lt;% } else { %&gt;+ &lt;i class=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;&lt;%= post.title %&gt;+ &lt;% } %&gt;+ &lt;/h1&gt; &lt;% if (post.layout != 'page') { %&gt; &lt;div class=&quot;level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto&quot;&gt; &lt;div class=&quot;level-left&quot;&gt;- &lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;i class=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt;+ &lt;time class=&quot;level-item has-text-grey is-hidden-mobile&quot; datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot;&gt;&lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;+ &lt;% } %&gt; &lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; 其中创建时间使用日期。 diff:source/js/main.js12345- if (typeof(moment) === 'function') {- $('.article-meta time').each(function () {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时也显示 tags，并且将 Read More 按钮放置在右边。 diff:layout/common/article.ejs123456789101112131415161718192021222324252627282930313233343536 &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt; &lt;div class=&quot;level is-size-7 is-uppercase&quot;&gt; &lt;div class=&quot;level-start&quot;&gt; &lt;div class=&quot;level-item&quot;&gt;- &lt;span class=&quot;is-size-6 has-text-grey has-mr-7&quot;&gt;#&lt;/span&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp; &lt;%- list_tags(post.tags, { class: 'has-link-grey ', show_count: false,- style: 'link'+ style: 'link',+ separator: ',&amp;nbsp;' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; &lt;% if (index &amp;&amp; post.excerpt) { %&gt;- &lt;div class=&quot;level is-mobile&quot;&gt;+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt;+ &lt;div class=&quot;level is-mobile is-flex&quot;&gt;+ &lt;div class=&quot;level-start&quot;&gt;+ &lt;% if (post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;div class=&quot;level-item is-size-7 is-uppercase&quot;&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;+ &lt;%- list_tags(post.tags, {+ class: 'has-link-grey ',+ show_count: false,+ style: 'link',+ separator: ',&amp;nbsp;'+ }) %&gt;+ &lt;/div&gt;+ &lt;% } %&gt;+ &lt;/div&gt; &lt;div class=&quot;level-start&quot;&gt; 优化个人信息布局减少头像大小，头像下方计数的地方增加链接，follow前增加icon。 diff:layout/widget/profile.ejs1234567- &lt;nav class=&quot;level is-mobile&quot;&gt;+ &lt;nav class=&quot;level menu-list is-mobile&quot; style=&quot;margin-bottom:1rem&quot;&gt; &lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt;- &lt;div&gt;+ &lt;a href=&quot;&lt;%- url_for('/archives/') %&gt;&quot;&gt; &lt;p class=&quot;heading&quot;&gt;...... 优化移动端显示在移动端，隐藏 archive 和 tagcloud。 diff:layout/widget/archive.ejs12-&lt;div class=&quot;card widget&quot;&gt;+&lt;div class=&quot;card widget is-hidden-mobile&quot;&gt; diff:layout/widget/tagcloud.ejs12-&lt;div class=&quot;card widget&quot;&gt;+&lt;div class=&quot;card widget is-hidden-mobile&quot;&gt; 目录粘性布局增加 column-left is-sticky 类。 diff:layout/widget/toc.ejs12-&lt;div class=&quot;card widget&quot; id=&quot;toc&quot;&gt;+&lt;div class=&quot;card widget column-left is-sticky&quot; id=&quot;toc&quot;&gt; 功能增加版权说明diff:layout/common/article.ejs1234567891011121314 &lt;div class=&quot;content&quot;&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt; &lt;/div&gt;+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;+ &lt;ul class=&quot;post-copyright&quot;&gt;+ &lt;li&gt;&lt;strong&gt;本文标题：&lt;/strong&gt;&lt;a href=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;&lt;a href=&quot;&lt;%= theme.url %&gt;&quot;&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文链接：&lt;/strong&gt;&lt;a href=&quot;&lt;%= post.permalink %&gt;&quot;&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;发布时间：&lt;/strong&gt;&lt;%= post.date.format(&quot;YYYY-MM-DD&quot;) %&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt; 许可协议。转载请注明出处！+ &lt;/li&gt;+ &lt;/ul&gt;+ &lt;% } %&gt; &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 并增加样式 diff:source/css/style.styl12345678+.post-copyright+ font-size: 1rem+ letter-spacing: 0.02rem+ word-break: break-all+ margin: 2.5rem 0 0+ padding: 1rem 1rem+ border-left: 3px solid #FF1700+ background-color: #F9F9F9 增加标题自动计数diff:source/css/style.styl1234567+.article {counter-reset:section}+.article h2{counter-reset:sub-section}+.article h3{counter-reset:composite}+.article h4{counter-reset:detail}+.article h2:before{content:counter(section) &quot; &quot;;counter-increment:section}+.article h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section}+.article h4:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite} 默认显示目录正常开启目录需要在 meta 信息中加入 toc: true 开启，但绝大部分文章都是有目录的，因此修改为默认开启。因为有多个地方引用了 get_config('toc') 并且需要判断当前页面，改起来稍微麻烦一些，因此直接修改了 get_config 方法。 diff:includes/helpers/config.js1234567 return defaultValue; } else { const property = readProperty(specs, configName);- return property === null ? null : property[descriptors.defaultValue];+ const result = property === null ? null : property[descriptors.defaultValue];+ return (configName === 'toc' &amp;&amp; this.page.layout === 'post' &amp;&amp; result === null) ? true : result; } 页面footer显示一组icon默认情况下一个icon对应一个链接，但例如 CC BY-NC-SA 4.0 需要四个图标一组。因此修改代码，使得配置 link.icon 可以是一个数组，效果可以参考页面底部。 diff:layout/common/footer.ejs1234 &lt;% } else { %&gt;- &lt;i class=&quot;&lt;%= link.icon %&gt;&quot;&gt;&lt;/i&gt;+ &lt;% for (let icon of (Array.isArray(link.icon) ? link.icon : [link.icon])) { %&gt;&lt;i class=&quot;&lt;%= icon %&gt;&quot;&gt;&lt;/i&gt;&amp;nbsp;&lt;% } %&gt; &lt;% } %&gt; diff:includes/specs/icon_link.spec.js12345 icon: { [required]: true,- [type]: 'string',+ [type]: ['string', 'array'], [doc]: 'Link icon class names' _config.yml 中配置如下 _config.yml123456789footer: links: CC BY-NC-SA 4.0: icon: - fab fa-creative-commons - fab fa-creative-commons-by - fab fa-creative-commons-nc - fab fa-creative-commons-sa url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 可以配置文章开头是否显示图片Icarus 支持文章设置一个图片，在文章开头、最近的文章、时间线等地方显示。但有些图放大之后会显得很不协调，因此修改以支持自定义是否显示。修改 has_thumbnail 方法，增加参数 isArticle 参数，默认 false，并在文章页面修改调用参数。 diff:includes/helpers/page.js1234567891011- hexo.extend.helper.register('has_thumbnail', function (post) {+ hexo.extend.helper.register('has_thumbnail', function (post, isArticle = false) { const getConfig = hexo.extend.helper.get('get_config').bind(this); const allowThumbnail = getConfig('article.thumbnail', true); if (!allowThumbnail) { return false; }+ if (isArticle &amp;&amp; post['article-thumbnail'] === false){+ return false;+ } return post.hasOwnProperty('thumbnail') &amp;&amp; post.thumbnail; diff:layout/common/article.ejs1234 &lt;div class=&quot;card&quot;&gt;- &lt;% if (has_thumbnail(post)) { %&gt;+ &lt;% if (has_thumbnail(post, true)) { %&gt; &lt;div class=&quot;card-image&quot;&gt; 这样修改之后，如果文章 meta 信息中包含 article-thumbnail: false，就可以取消图片的显示。 样式修改 logo 和 favicon用 Python 设计 Logo，并微调样式。 按钮背景颜色增加渐变diff:source/css/style.styl123456 .menu-list li ul margin-right: 0+ .menu-list a+ transition: background-color 0.3s ease-in-out .menu-list a.level display: flex card 增加浮动效果:hover 时增大阴影，并增加动画属性 ease-in-out。 diff:source/css/style.styl12345 .card border-radius: 4px box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1)+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) diff:source/js/animation.js123 element.style.transform = '';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; 更新2020-02-16 合并了 2.7.0 版本，冲突不算太多，有两个点需要注意一下。 icarus 的配置里面，plugins.clipboard 需要移除，相关的配置移动到 article.highlight.clipboard。 _config.yml12345678910article: # Code highlight settings highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: github-gist # Show code copying button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded 如果之前 links widget 没有配置链接，可能会遇到编译错误，需要增加一下判断。 diff:layout/widget/links.locals.js12345 const links = get_config_from_obj(locals.widget, 'links');- if (Object.keys(links).length == 0) {+ if (!links || Object.keys(links).length == 0) { return null; } 总结这里只列举了部分改动，详细的差异可以查看 diff。 本文会持续更新，保持跟最新的博客效果一致，希望能给你自定义主题一些帮助。 如果有其他想法或者意见，可以在下方留言。 😊","link":"/2019/03/customize-icarus-2/"},{"title":"Ubuntu 内核升级","text":"Linux 内核大概几天就会有一个小版本更新，几个月就会有一次主要版本的更新，例如： 2018-10-22 v4.19 2018-12-24 v4.20 2019-03-04 v5.0 2019-03-10 v5.0.1 2019-03-14 v5.0.2 2019-03-19 v5.0.3 为了使用一些新的特性，或者为了提升性能和安全性，或者只是为了修复某些问题，需要对内核进行单独升级。 The Linux Kernel ArchivesUbuntu Kernel Mainline 升级内核正常情况下不会出现问题，但不排除可能会出现问题，请合理评估风险。 查看当前内核版本可以通过 uname 查看当前内核版本， 12$ uname -srLinux 4.4.0-92-generic 或者输入 uname -a 查看完整信息。 Ubuntu 内核升级最好是升级到长期支持版（longterm）本或者稳定版（stable），可以在 The Linux Kernel Archives查看当前的版本，这里以 longterm: 4.19.36 为例。 之后在 Ubuntu Kernel Mainline 找到对应的版本号，https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.36/ 。 在对应的架构Build for xxx succeeded，下载不包含 lowlatency 的所有deb文件。例如在 x86_64 下，总共需要下载4个文件。 1234linux-headers-4.19.36-041936_4.19.36-041936.201904200430_all.deblinux-headers-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deblinux-image-unsigned-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deblinux-modules-4.19.36-041936-generic_4.19.36-041936.201904200430_amd64.deb 安装 1sudo dpkg -i linux-*.deb 重启 1sudo reboot 确认升级成功 12$ uname -srLinux 4.19.36-041936-generic 这里看到内核版本已经升级成功了，其他版本或者架构操作也类似。 删除旧的内核版本如果确实要移除旧的内核版本，可以通过该命令查看已经安装的内核版本， 1dpkg --get-selections | grep linux 然后直接使用 apt-get purge 删除旧版本的包（有明确的版本号）。 总结还有一些其他方法，例如直接用 apt-get 升级，还有一些工具，具体可以参考 How to update kernel to the latest mainline version without any Distro-upgrade?","link":"/2019/04/kernel-update/"},{"title":"用 Python 设计 Logo","text":"用 Python 设计一个简单的 logo 。 预览logo.svg favicon.svg 代码代码只依赖 matplotlib。 12345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltlines = [[[1, 4], [5, 8.08]], [[1, 4], [5, 1.92]], [[5, 9], [2.96, 7.04]], [[5, 6.5], [7.04, 5.5]], [[8, 9], [4, 2.96]]]color = '#00a4ef'linewidth = 28# favicon.svgplt.figure(figsize=(4, 4))plt.axis('off')plt.axis([0, 10, 0, 10])for l in lines: plt.plot(l[0], l[1], color, linewidth=linewidth)plt.savefig('favicon.svg')# logo.svgplt.figure(figsize=(10, 4))plt.axis('off')plt.axis([0, 25, 0, 10])for l in lines: plt.plot(l[0], l[1], color, linewidth=linewidth)plt.text(11, 2, 'Lxy', fontsize=180)plt.savefig('logo.svg') SVG 压缩压缩SVG可以减少图片大小，尝试了几个在线压缩svg的网站，效果都不太理想，主要是形状处理不准确，跟原图显示不一样。后来试了 https://vecta.io/nano 效果非常好而且压缩率也不错，上述两张图片压缩率超过 60% 。 替换本博客使用的是 icarus 主题，在 themes/icarus/source/img 目录下替换 favicon.svg 和 logo.svg 即可，其他主题操作也类似。","link":"/2019/03/python-logo/"},{"title":"Icarus 主题自定义","text":"本文是基于icarus 4.x的版本，icarus在2.0使用的是ejs，如果需要请查看旧版本。 本博客所选取的主题是 Icarus ，并做了一些个性化的修改，很多修改都可以直观的看到。详细的差异可以查看 diff，这里记录一些主要的改动。 布局文章页面两栏布局主题默认是三栏布局，在阅读文章时显得有些拥挤。可以通过配置的方式把所有文章变为两栏布局，在_config.post.yml把需要的widget显示在一边即可，可以参考官方文档。 但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 diff:layout/layout.jsx1234 &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; diff:layout/layout.jsx1234 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 diff:layout/common/widgets.jsx12345678 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 并优化在不同屏幕小大下的宽度 diff:include/style/responsive.styl1234567891011121314151617 +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon diff:layout/common/article.jsx123456789101112131415161718192021222324252627282930313233 &lt;article class={`card-content article${'direction' in page ? ' ' + page.direction : ''}`} role=&quot;article&quot;&gt; {/* Metadata */}+ {/* Title */}+ &lt;h1 className=&quot;title is-size-3 is-size-4-mobile has-text-weight-normal&quot;&gt;+ {index ?+ &lt;a className=&quot;has-link-black-ter&quot; href={url_for(page.link || page.path)}&gt;+ &lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;{page.title}+ &lt;/a&gt; :+ [&lt;i className=&quot;fas fa-angle-double-right&quot;&gt;&lt;/i&gt;, page.title]+ }+ &lt;/h1&gt; {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; &lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */}- {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.created_at', `&lt;time dateTime=&quot;${date_xml(page.date)}&quot; title=&quot;${new Date(page.date).toLocaleString()}&quot;&gt;${date(page.date)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {page.date &amp;&amp; &lt;span class=&quot;level-item&quot;&gt;+ &lt;i className=&quot;far fa-calendar-alt&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime={date_xml(page.date)} title={date_xml(page.date)}&gt;{date(page.date)}&lt;/time&gt;+ &lt;/span&gt;} {/* Last Update Date */}- {page.updated &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{- __html: _p('article.updated_at', `&lt;time dateTime=&quot;${date_xml(page.updated)}&quot; title=&quot;${new Date(page.updated).toLocaleString()}&quot;&gt;${date(page.updated)}&lt;/time&gt;`)- }}&gt;&lt;/span&gt;}+ {shouldShowUpdated &amp;&amp; &lt;span class=&quot;level-item is-hidden-mobile&quot;&gt;+ &lt;i class=&quot;far fa-calendar-check&quot;&gt;&amp;nbsp;&lt;/i&gt;+ &lt;time dateTime={date_xml(page.updated)} title={date_xml(page.updated)}&gt;{date(page.updated)}&lt;/time&gt;+ &lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} 其中时间直接使用日期 diff:source/js/main.js12345- if (typeof moment === 'function') {- $('.article-meta time').each(function() {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时（主页）也显示 tags，并且将 Read More 按钮放置在右边。 diff:layout/common/article.jsx123456789101112131415161718192021 {/* Licensing block */} {!index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null}+ &lt;hr style=&quot;height:1px;margin:1rem 0&quot;/&gt;+ &lt;div className=&quot;level is-mobile is-flex&quot;&gt; {/* Tags */}- {!index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt;- &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt;- {page.tags.map(tag =&gt; {- return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;;+ {page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 is-uppercase&quot;&gt;+ &lt;i class=&quot;fas fa-tags has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;+ {page.tags.map((tag, index) =&gt; {+ return &lt;a class=&quot;link-muted&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}{index !== page.tags.length-1? ', ':''}&lt;/a&gt;; })} &lt;/div&gt; : null} {/* &quot;Read more&quot; button */}- {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null}+ {index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;&lt;i class=&quot;fas fa-book-reader has-text-grey&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;{__('article.more')}&lt;/a&gt; : null}+ &lt;/div&gt; {/* Share button */} 优化个人信息布局减少头像大小，头像下方计数的地方增加链接，follow前增加icon。 diff:layout/widget/profile.jsx123456789101112- &lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt;+ &lt;a class=&quot;level-item has-text-centered is-marginless&quot; href={counter.category.url}&gt; &lt;div&gt; &lt;p class=&quot;heading&quot;&gt;{counter.category.title}&lt;/p&gt;- &lt;a href={counter.category.url}&gt;+ &lt;div&gt; &lt;p class=&quot;title&quot;&gt;{counter.category.count}&lt;/p&gt;- &lt;/a&gt;+ &lt;/div&gt; &lt;/div&gt;- &lt;/div&gt;+ &lt;/a&gt; 优化移动端显示在移动端，隐藏 archive 和 tags。 diff:source/js/main.js12345 }++ $('div.container div.card[data-type=tags]').addClass('is-hidden-mobile');+ $('div.container div.card[data-type=archives]').addClass('is-hidden-mobile'); }(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings)); 目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 diff:source/js/main.js123 if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); diff:include/style/widget.styl123+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 功能增加默认缩略图diff:layout/layout.jsx12345 const { site, config, page, helper, body } = this.props;+ site.posts &amp;&amp; site.posts.filter(p =&gt; !p.thumbnail).forEach(p =&gt; p.thumbnail = '/img/thumbnail.svg');+ const language = page.lang || page.language || config.language; diff:layout/archive.jsx12345 const { url_for, __, date_xml, date } = helper;+ page.posts &amp;&amp; page.posts.filter(p =&gt; !p.thumbnail).forEach(p =&gt; p.thumbnail = '/img/thumbnail.svg');+ const language = page.lang || page.language || config.language; 增加许可协议新版已经支持许可协议，直接配置即可，参考官方文档。 增加标题自动计数diff:include/style/article.styl1234567+.article {counter-reset:section}+.article h2{counter-reset:sub-section}+.article h3{counter-reset:composite}+.article h4{counter-reset:detail}+.article h2:before{content:counter(section) &quot; &quot;;counter-increment:section}+.article h3:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot; &quot;;counter-increment:sub-section}+.article h4:before{content:counter(section) &quot;.&quot; counter(sub-section) &quot;.&quot; counter(composite) &quot; &quot;;counter-increment:composite} 默认显示目录新版支持直接配置，在_config.yml增加toc: true即可。 页面footer显示一组icon默认情况下一个icon对应一个链接，但例如 CC BY-NC-SA 4.0 需要四个图标一组。因此修改代码，使得配置 link.icon 可以是一个数组，效果可以参考页面底部。 diff:layout/common/footer.jsx123456789101112 const link = links[name]; return &lt;p class=&quot;control&quot;&gt; &lt;a class={`button is-transparent ${link.icon ? 'is-large' : ''}`} target=&quot;_blank&quot; rel=&quot;noopener&quot; title={name} href={link.url}&gt;- {link.icon ? &lt;i class={link.icon}&gt;&lt;/i&gt; : name}+ {link.icon ?+ (Array.isArray(link.icon) ?+ link.icon.map(i =&gt; [&lt;i className={i}&gt;&lt;/i&gt;, '\\u00A0']) :+ &lt;i className={link.icon}&gt;&lt;/i&gt;+ ) : name} &lt;/a&gt; &lt;/p&gt;; })} 忽略校验的schema diff:include/schema/common/footer.json1- &quot;$ref&quot;: &quot;/misc/poly_links.json&quot;, _config.yml 中配置如下 _config.yml123456789footer: links: CC BY-NC-SA 4.0: icon: - fab fa-creative-commons - fab fa-creative-commons-by - fab fa-creative-commons-nc - fab fa-creative-commons-sa url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/' 样式修改 logo 和 favicon用 Python 设计 Logo，并微调样式。 按钮背景颜色增加渐变diff:include/style/widget.styl123456789 .widget .menu-list li ul margin-right: 0+ a+ transition: background-color 0.3s ease-in-out .level margin-bottom: 0 card 增加浮动效果:hover 时增大阴影，并增加动画属性 ease-in-out。 diff:include/style/card.styl12345 .card overflow: visible border-radius: $card-radius+ &amp;:hover+ box-shadow: 0 6px 15px rgba(0,0,0,0.15), 0 0 1px rgba(0,0,0,0.1) diff:source/js/animation.js123456 setTimeout(() =&gt; { $('body &gt; .navbar, body &gt; .section, body &gt; .footer').forEach(element =&gt; { element.style.opacity = '1';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }); diff:source/js/animation.js1234 element.style.transform = '';- element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';+ element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out, box-shadow 0.3s ease-in-out'; }, i * 100); 修改tag的颜色diff:include/style/widget.styl1234567891011 .tags .tag:first-child- background: $primary- color: $primary-invert+ background: whitesmoke+ color: #4a4a4a .tag:last-child- background: $light-grey+ background: #e7e7e7 color: $white-invert 更新2020-12-04 基于 4.1.1 版本重新改动。2021-09-06 合并 4.4.0，官方也支持文章 licenses配置多个图标，不过目前还是自己实现的。 总结这里只列举了部分改动，详细的差异可以查看 diff。 本文会持续更新，保持跟最新的博客效果一致，希望能给你自定义主题一些帮助。 如果有其他想法或者意见，可以在下方留言。","link":"/2019/03/customize-icarus/"},{"title":"Quine 自产生程序 — Java","text":"Quine 以哲学家奎恩（Willard Van Orman Quine）命名，指的是输出结果为程序自身源码的程序，也称为 自产生程序。有点类似于代码中的不动点，举一个例子 quine.py1exec(s:='print(&quot;exec(s:=%r)&quot;%s)') 那么以下命令全部输出 exec(s:='print(&quot;exec(s:=%r)&quot;%s)') 123python quine.pypython -c $(python quine.py)python -c $(python -c $(python quine.py)) 理论上图灵完备的语言都可以构造出 Quine，那么如何在 Java 中构造呢？ 维基百科的例子下面的例子来自维基百科 https://en.wikipedia.org/wiki/Quine_(computing) 12345678910111213141516171819202122232425262728293031public class Quine{ public static void main(String[] args) { char q = 34; // Quotation mark character String[] l = { // Array of source code &quot;public class Quine&quot;, &quot;{&quot;, &quot; public static void main(String[] args)&quot;, &quot; {&quot;, &quot; char q = 34; // Quotation mark character&quot;, &quot; String[] l = { // Array of source code&quot;, &quot; &quot;, &quot; };&quot;, &quot; for(int i = 0; i &lt; 6; i++) // Print opening code&quot;, &quot; System.out.println(l[i]);&quot;, &quot; for(int i = 0; i &lt; l.length; i++) // Print string array&quot;, &quot; System.out.println(l[6] + q + l[i] + q + ',');&quot;, &quot; for(int i = 7; i &lt; l.length; i++) // Print this code&quot;, &quot; System.out.println(l[i]);&quot;, &quot; }&quot;, &quot;}&quot;, }; for(int i = 0; i &lt; 6; i++) // Print opening code System.out.println(l[i]); for(int i = 0; i &lt; l.length; i++) // Print string array System.out.println(l[6] + q + l[i] + q + ','); for(int i = 7; i &lt; l.length; i++) // Print this code System.out.println(l[i]); }} 大概的原理是（是一个通用的模式） 在代码中预留一个字符串数组，每个元素代表一行代码 先输出代码到数组之前 String[] l = { 的行 再输出数组（需要处理缩进） 再输出剩下的行 最后把这个代码粘贴到数组中 还有一个 Java 15 及以上（text blocks）的例子 1234567891011121314151617public class Quine { public static void main(String[] args) { String textBlockQuotes = new String(new char[]{'&quot;', '&quot;', '&quot;'}); char newLine = 10; String source = &quot;&quot;&quot;public class Quine { public static void main(String[] args) { String textBlockQuotes = new String(new char[]{'&quot;', '&quot;', '&quot;'}); char newLine = 10; String source = %s; System.out.print(source.formatted(textBlockQuotes + newLine + source + textBlockQuotes)); }}&quot;&quot;&quot;; System.out.print(source.formatted(textBlockQuotes + newLine + source + textBlockQuotes)); }} 转义字符上面的例子是通过 %s 替换自身代码来完成的，之前的 Java 版本中需要对换行和双引号进行转义。按照这个思路可以替换成如下实现（通过 char 跳过转义） 1234567891011121314151617public class Quine { public static void main(String[] args) { char quote = 34; char[] replace = {92,'n',34,10,32,32,32,32,32,32,32,32,32,32,32,32,'+',32,34}; String source = &quot;public class Quine {\\n&quot; + &quot; public static void main(String[] args) {\\n&quot; + &quot; char quote = 34;\\n&quot; + &quot; char[] replace = {92,'n',34,10,32,32,32,32,32,32,32,32,32,32,32,32,'+',32,34};\\n&quot; + &quot; String source = %s;\\n&quot; + &quot; String self = source.replace(String.valueOf((char)10), new String(replace));\\n&quot; + &quot; System.out.print(String.format(source, quote + self + quote));\\n&quot; + &quot; }\\n&quot; + &quot;}&quot;; String self = source.replace(String.valueOf((char)10), new String(replace)); System.out.print(String.format(source, quote + self + quote)); }} 代码会有点麻烦（为了保留格式），上面 replace 代码相当于 1source.replace(&quot;\\n&quot;, &quot;\\\\n\\&quot;\\n + \\&quot;&quot;) 如果不考虑格式和换行的话（只能写在一行了） 1class Q{public static void main(String[]a){String s=&quot;class Q{public static void main(String[]a){String s=%c%s%1$c;System.out.printf(s,34,s);}}&quot;;System.out.printf(s,34,s);}} 这里还有更多的例子 http://www.nyx.net/~gthompso/self_java.txt 。 还有一种更加通用的方案，通过编码的方式绕过转义字符的影响，参考 https://www.zhihu.com/question/22006572/answer/47923822 先写一个通用的代码 1234567public class Quine { public static void main(String[] args) { String s = &quot;__&quot;; // 通过 URLDecoder System.out.println(java.net.URLDecoder.decode(s).replaceFirst(&quot;__&quot;, s)); }} 然后把上面的代码通过 URLEncoder 编码，然后替换引号里面 1234567public class Quine { public static void main(String[] args) { String s = &quot;public+class+Quine+%7B%0A++++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++++String+s+%3D+%22__%22%3B%0A++++++++%2F%2F+%E9%80%9A%E8%BF%87+URLDecoder%0A++++++++System.out.println%28java.net.URLDecoder.decode%28s%29.replaceFirst%28%22__%22%2C+s%29%29%3B%0A++++%7D%0A%7D&quot;; // 通过 URLDecoder System.out.println(java.net.URLDecoder.decode(s).replaceFirst(&quot;__&quot;, s)); }} 同理 1234567public class Quine { public static void main(String[] args) { String s = &quot;cHVibGljIGNsYXNzIFF1aW5lIHsKICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBtYWluKFN0cmluZ1tdIGFyZ3MpIHsKICAgICAgICBTdHJpbmcgcyA9ICJfXyI7CiAgICAgICAgLy8g6YCa6L+HIEJhc2U2NAogICAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihuZXcgU3RyaW5nKGphdmEudXRpbC5CYXNlNjQuZ2V0RGVjb2RlcigpLmRlY29kZShzKSkucmVwbGFjZUZpcnN0KCJfXyIsIHMpKTsKICAgIH0KfQ==&quot;; // 通过 Base64 System.out.println(new String(java.util.Base64.getDecoder().decode(s)).replaceFirst(&quot;__&quot;, s)); }} Ouroboros programs div.ouroboros > div { display: inline-block; vertical-align: top; width: 49%; } public class Quine{ public static void main(String[] args) { char q = 34; String[] l = { &quot; &quot;, &quot;=============&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; C++ Code &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;=============&quot;, &quot;#include &lt;iostream&gt;&quot;, &quot;#include &lt;string&gt;&quot;, &quot;using namespace std;&quot;, &quot;&quot;, &quot;int main(int argc, char* argv[])&quot;, &quot;{&quot;, &quot; char q = 34;&quot;, &quot; string l[] = {&quot;, &quot; };&quot;, &quot; for(int i = 20; i &lt;= 25; i++)&quot;, &quot; cout &lt;&lt; l[i] &lt;&lt; endl;&quot;, &quot; for(int i = 0; i &lt;= 34; i++)&quot;, &quot; cout &lt;&lt; l[0] + q + l[i] + q + ',' &lt;&lt; endl;&quot;, &quot; for(int i = 26; i &lt;= 34; i++)&quot;, &quot; cout &lt;&lt; l[i] &lt;&lt; endl;&quot;, &quot; return 0;&quot;, &quot;}&quot;, &quot;=============&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Java Code &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;==========&quot;, &quot;public class Quine&quot;, &quot;{&quot;, &quot; public static void main( String[] args )&quot;, &quot; {&quot;, &quot; char q = 34;&quot;, &quot; String[] l = {&quot;, &quot; };&quot;, &quot; for(int i = 2; i &lt;= 9; i++)&quot;, &quot; System.out.println(l[i]);&quot;, &quot; for(int i = 0; i &lt; l.length; i++)&quot;, &quot; System.out.println( l[0] + q + l[i] + q + ',' );&quot;, &quot; for(int i = 10; i &lt;= 18; i++))&quot;, &quot; System.out.println(l[i]);&quot;, &quot; }&quot;, &quot;}&quot;, }; for(int i = 2; i &lt;= 9; i++) System.out.println(l[i]); for(int i = 0; i &lt; l.length; i++) System.out.println( l[0] + q + l[i] + q + ',' ); for(int i = 10; i &lt;= 18; i++) System.out.println(l[i]); }} #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char* argv[]){ char q = 34; string l[] = { &quot; &quot;, &quot;=============&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; C++ Code &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;=============&quot;, &quot;#include &lt;iostream&gt;&quot;, &quot;#include &lt;string&gt;&quot;, &quot;using namespace std;&quot;, &quot;&quot;, &quot;int main(int argc, char* argv[])&quot;, &quot;{&quot;, &quot; char q = 34;&quot;, &quot; string l[] = {&quot;, &quot; };&quot;, &quot; for(int i = 20; i &lt;= 25; i++)&quot;, &quot; cout &lt;&lt; l[i] &lt;&lt; endl;&quot;, &quot; for(int i = 0; i &lt;= 34; i++)&quot;, &quot; cout &lt;&lt; l[0] + q + l[i] + q + ',' &lt;&lt; endl;&quot;, &quot; for(int i = 26; i &lt;= 34; i++)&quot;, &quot; cout &lt;&lt; l[i] &lt;&lt; endl;&quot;, &quot; return 0;&quot;, &quot;}&quot;, &quot;=============&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Java Code &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;=============&quot;, &quot;public class Quine&quot;, &quot;{&quot;, &quot; public static void main(String[] args)&quot;, &quot; {&quot;, &quot; char q = 34;&quot;, &quot; String[] l = {&quot;, &quot; };&quot;, &quot; for(int i = 2; i &lt;= 9; i++)&quot;, &quot; System.out.println( l[i] );&quot;, &quot; for(int i = 0; i &lt; l.length; i++)&quot;, &quot; System.out.println(l[0] + q + l[i] + q + ',');&quot;, &quot; for(int i = 10; i &lt;= 18; i++)&quot;, &quot; System.out.println(l[i]);&quot;, &quot; }&quot;, &quot;}&quot;, }; for(int i = 20; i &lt;= 25; i++) cout &lt;&lt; l[i] &lt;&lt; endl; for(int i = 0; i &lt;= 34; i++) cout &lt;&lt; l[0] + q + l[i] + q + ',' &lt;&lt; endl; for(int i = 26; i &lt;= 34; i++) cout &lt;&lt; l[i] &lt;&lt; endl; return 0;} 这个例子来自维基百科 https://en.wikipedia.org/wiki/Quine_(computing) 两段代码结构上非常相似，而且跟第一个例子也很像。Java 的代码输出 C++ 的代码，C++ 的代码输出 Java 的代码，循环生成。 也可以用上面占位符的思路，这里演示多个 Java 代码相互生成的例子，class A -&gt; class B -&gt; class C 123456789101112131415public class A { public static void main(String[] args) { String s = &quot;public+class A+%7B%0A++++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++++String+s+%3D+%22__%22%3B%0A++++++++String+code+%3D+java.net.URLDecoder.decode%28s%29.replaceFirst%28%22__%22%2C+s%29%3B%0A++++++++String+a+%3D+%22class+%22+%2B+%22A%22%3B%0A++++++++String+b+%3D+%22class+%22+%2B+%22B%22%3B%0A++++++++String+c+%3D+%22class+%22+%2B+%22C%22%3B%0A++++++++if+%28code.contains%28a%29%29+%7B%0A++++++++++++code+%3D+code.replaceAll%28a%2C+b%29%3B%0A++++++++%7D+else+if+%28code.contains%28b%29%29+%7B%0A++++++++++++code+%3D+code.replaceAll%28b%2C+c%29%3B%0A++++++++%7D%0A++++++++System.out.println%28code%29%3B%0A++++%7D%0A%7D&quot;; String code = java.net.URLDecoder.decode(s).replaceFirst(&quot;__&quot;, s); String a = &quot;class &quot; + &quot;A&quot;; String b = &quot;class &quot; + &quot;B&quot;; String c = &quot;class &quot; + &quot;C&quot;; if (code.contains(a)) { code = code.replaceAll(a, b); } else if (code.contains(b)) { code = code.replaceAll(b, c); } System.out.println(code); }} 其他语言的例子下面的例子来自 https://rosettacode.org/wiki/Quine C12#include &lt;stdio.h&gt;int main(){char*c=&quot;#include &lt;stdio.h&gt;%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c&quot;;printf(c,10,34,c,34,10);return 0;} Go12345678package main import &quot;fmt&quot; func main() { a := &quot;package main\\n\\nimport \\&quot;fmt\\&quot;\\n\\nfunc main() {\\n\\ta := %q\\n\\tfmt.Printf(a, a)\\n}\\n&quot; fmt.Printf(a, a)} JavaScript1(f=_=&gt;`(f=${f})()`)() Quine Relayhttps://github.com/mame/quine-relay This is a Ruby program that generates Rust program that generates Scala program that generates …(through 128 languages in total)… REXX program that generates the original Ruby code again. 多种语言的 Quine 循环， Ruby -&gt; Rust -&gt; Scala -&gt; ... -&gt; Ruby 最终生成跟原来相同的 Ruby 程序，一共 128 种语言。原理可以参考 https://www.zhihu.com/question/21568155 。 参考https://en.wikipedia.org/wiki/Quine_(computing)http://www.nyx.net/~gthompso/quine.htmhttps://www.zhihu.com/question/22006572https://github.com/mame/quine-relayhttps://rosettacode.org/wiki/Quine","link":"/2021/09/quine-java/"},{"title":"Java 进阶 — 类加载机制","text":"类加载机制是 Java 技术体系中非常核心的部分，负责把 class 文件加载到 JVM。 类加载器可以说是 Java 语言的一项创新，它是早期 Java 语言能够快速流行的重要原因之一。类加载器最初是为了满足 Java Applet 的需求而设计出来的，在今天用在浏览器上的 Java Applet 技术基本上已经被淘汰，但类加载器却在类层次划分、OSGi、程序热部署、代码加密等领域大放异彩，成为 Java 技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。 ——《深入理解 Java 虚拟机》 开始之前先抛出五个问题，看看能否给出准确的回答 如何启动一个 Java 应用？JVM 启动的时候是如何查找类的？ 是先有的 Class 还是先有的 ClassLoader？JVM 启动的时候是如何处理 ClassLoader 的？ ClassLoader 的层次结构是什么样的？双亲委派模型是什么？contextClassLoader 是什么？ 类加载过程中会遇到哪些错误 Error 或者异常 Exception？NoClassDefFoundError 和 ClassNotFoundException 区别是什么？ 什么情况下需要自定义 ClassLoader？如何自定义 ClassLoader？ Java 应用启动无论是通过什么脚本启动还是在 IDE 里面直接执行，最终都是通过执行 java 命令。 IDEA 启动应用的第一行日志 mvn 命令，其实是个脚本 apache-maven-3.6.3/bin/mvn12345678910111213141516# ...# Provide a &quot;standardized&quot; way to retrieve the CLI args that will# work with both Windows and non-Windows executions.MAVEN_CMD_LINE_ARGS=&quot;$MAVEN_CONFIG $@&quot;export MAVEN_CMD_LINE_ARGSexec &quot;$JAVACMD&quot; \\ $MAVEN_OPTS \\ $MAVEN_DEBUG_OPTS \\ -classpath &quot;${CLASSWORLDS_JAR}&quot; \\ &quot;-Dclassworlds.conf=${MAVEN_HOME}/bin/m2.conf&quot; \\ &quot;-Dmaven.home=${MAVEN_HOME}&quot; \\ &quot;-Dlibrary.jansi.path=${MAVEN_HOME}/lib/jansi-native&quot; \\ &quot;-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}&quot; \\ ${CLASSWORLDS_LAUNCHER} &quot;$@&quot; 来看一下 java 命令的帮助 12345$ java -helpUsage: java [-options] class [args...] (to execute a class) or java [-options] -jar jarfile [args...] (to execute a jar file) 文档中对于 Java 启动时类查找的说明 https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html How the Java Launcher Finds Classes The Java launcher, java, initiates the Java virtual machine. The virtual machine searches for and loads classes in this order: Bootstrap classes - Classes that comprise the Java platform, including the classes in rt.jar and several other important jar files. Extension classes - Classes that use the Java Extension mechanism. These are bundled as .jar files located in the extensions directory. User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. div.inline-code-gray code { color: steelblue !important } How the Java Launcher Finds User Classes User classes are classes which build on the Java platform. To find user classes, the launcher refers to the user class path – a list of directories, JAR archives, and ZIP archives which contain class files.A class file has a subpath name that reflects the class’s fully-qualified name. For example, if the class com.mypackage.MyClass is stored under /myclasses, then /myclasses must be in the user class path and the full path to the class file must be /myclasses/com/mypackage/MyClass.class. If the class is stored in an archive named myclasses.jar, then myclasses.jar must be in the user class path, and the class file must be stored in the archive as com/mypackage/MyClass.class.The user class path is specified as a string, with a colon (:) separating the class path entries on Solaris, and a semi-colon (;) separating entries on Microsoft Windows systems. The java launcher puts the user class path string in the java.class.path system property. The possible sources of this value are: The default value, “.”, meaning that user class files are all the class files in the current directory (or under it, if in a package). The value of the CLASSPATH environment variable, which overrides the default value. The value of the -cp or -classpath command line option, which overrides both the default value and the CLASSPATH value. The JAR archive specified by the -jar option, which overrides all other values. If this option is used, all user classes must come from the specified archive. IDE 和 mavenIDE 会通过 maven 插件，解析项目模块，计算 classpath，最终通过 -classpath 影响启动，所以修改依赖的时候需要重新加载项目。 IDE 多模块的 classpath每个模块的 classpath 是独立计算的，在不同模块启动 main 方法的的时候 -classpath 参数是不同的，例如有两个模块 A B，A 依赖 B 和第三方 C.jar , B 依赖第三方 D.jar 1234A├── C.jar└── B └──D.jar 最终启动 A 中的 main 方法（会指向对应模块的 target/classes 目录） 1java -classpath ${项目}/A/target/classes:${项目}/B/target/classes:${仓库}/C.jar:${仓库}/D.jar ... 如果是启动 B 中的 main 方法（此时是找不到 A 中定义类的） 1java -classpath ${项目}/B/target/classes:${仓库}/D.jar ... Spring 包扫描与 classpath 的关系Spring 只能扫描类加载能加载到的类，可以简单认为就是只能加载 classpath 下的类。 Object Class ClassLoader (java.lang.*)任何对象都是一个类的实例，那么 java.lang.String.class 是一个对象吗？（java.lang.Class extend java.lang.Object） Class 实例是通过 ClassLoader 的实例加载的，但 ClassLoader 实例本身也是一个对象，所以也会有 Class，下面这几个值是什么关系？ 1234Class.classClassLoader.classClass.class.getClassLoader()ClassLoader.class.getClassLoader() 从 JDK 源码看类的加载SystemDictionary 管理了所有加载的类 hotspot/src/share/vm/classfile/systemDictionary.hppsystemDictionary.hpp12345678class SystemDictionary : AllStatic { //... // Hashtable holding loaded classes. static Dictionary* _dictionary; //...} 而 Dictionary 就是一个 Hashtable hotspot/src/share/vm/classfile/dictionary.hppdictionary.hpp123class Dictionary : public TwoOopHashtable&lt;Klass*, mtClass&gt; { //...} 再来看下 Klass hotspot/src/share/vm/oops/klass.hppklass.hpp123456789// A Klass provides:// 1: language level class object (method dictionary etc.)// 2: provide vm dispatch behavior for the object// Both functions are combined into one C++ class.// ...class Klass : public Metadata { // ...} hotspot/src/share/vm/oops/instanceKlass.hppinstanceKlass.hpp123456789101112131415161718192021222324252627282930313233343536373839404142// An InstanceKlass is the VM level representation of a Java class.// It contains all information needed for at class at execution runtime.// InstanceKlass layout:// [C++ vtbl pointer ] Klass// [subtype cache ] Klass// [instance size ] Klass// [java mirror ] Klass// [super ] Klass// [access_flags ] Klass// [name ] Klass// [first subklass ] Klass// [next sibling ] Klass// [array klasses ]// [methods ]// [local interfaces ]// [transitive interfaces ]// [fields ]// [constants ]// [class loader ]// [source file name ]// [inner classes ]// [static field size ]// [nonstatic field size ]// [static oop fields size ]// [nonstatic oop maps size ]// [has finalize method ]// [deoptimization mark bit ]// [initialization state ]// [initializing thread ]// [Java vtable length ]// [oop map cache (stack maps) ]// [EMBEDDED Java vtable ] size in words = vtable_len// [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size// The embedded nonstatic oop-map blocks are short pairs (offset, length)// indicating where oops are located in instances of this klass.// [EMBEDDED implementor of the interface] only exist for interface// [EMBEDDED host klass ] only exist for an anonymous class (JSR 292 enabled)class InstanceKlass: public Klass { // ...} 在 hotspot 代码里面 Klass 是类的底层实现，类加载最终的结果就是创建一个 Klass （或其子类）对象，而 SystemDictionary 管理了所有的加载的类。 Java 虚拟机启动来看一下 JVM 启动的时候跟 ClassLoader 相关的主要流程，从 main 方法到 java main 方法 12345678910111213141516171819main (jdk/src/share/bin/main.c)-&gt; JLI_Launch (jdk/src/share/bin/java.c) -&gt; LoadJavaVM (jdk/src/share/bin/java.c) // 加载动态库找到hotspot实现 -&gt; JVMInit (jdk/src/share/bin/java.c) -&gt; ContinueInNewThread (jdk/src/share/bin/java.c) -&gt; ContinueInNewThread0 (jdk/src/solaris/bin/java_md_solinux.c) -&gt; JavaMain (jdk/src/share/bin/java.c) -&gt; InitializeJVM (jdk/src/share/bin/java.c) -&gt; JNI_CreateJavaVM (hotspot/src/share/vm/prims/jni.cpp) -&gt; Threads::create_vm (hotspot/src/share/vm/runtime/thread.cpp) -&gt; init_globals (hotspot/src/share/vm/runtime/init.cpp) -&gt; universe2_init (hotspot/src/share/vm/runtime/universe.cpp) -&gt; Universe::genesis (hotspot/src/share/vm/runtime/universe.cpp) -&gt; SystemDictionary::initialize (hotspot/src/share/vm/classfile/systemDictionary.cpp) -&gt; SystemDictionary::initialize_preloaded_classes (hotspot/src/share/classfile/systemDictionary.cpp) -&gt; SystemDictionary::compute_java_system_loader (hotspot/src/share/classfile/systemDictionary.cpp) -&gt; LoadMainClass (jdk/src/share/bin/java.c) // 加载 MainClass -&gt; GetStaticMethodID (jdk/src/share/bin/java.c) // 找 main 方法 -&gt; CallStaticVoidMethod (jdk/src/share/bin/java.c) // 调用 main 方法 hotspot/src/share/vm/classfile/systemDictionary.hppsystemDictionary.hpp12345678910111213141516171819202122232425262728293031323334#define WK_KLASSES_DO(do_klass) \\ /* well-known classes */ \\ do_klass(Object_klass, java_lang_Object, Pre ) \\ do_klass(String_klass, java_lang_String, Pre ) \\ do_klass(Class_klass, java_lang_Class, Pre ) \\ do_klass(Cloneable_klass, java_lang_Cloneable, Pre ) \\ do_klass(ClassLoader_klass, java_lang_ClassLoader, Pre ) \\ do_klass(Serializable_klass, java_io_Serializable, Pre ) \\ do_klass(System_klass, java_lang_System, Pre ) \\ do_klass(Throwable_klass, java_lang_Throwable, Pre ) \\ do_klass(Error_klass, java_lang_Error, Pre ) \\ do_klass(ThreadDeath_klass, java_lang_ThreadDeath, Pre ) \\ do_klass(Exception_klass, java_lang_Exception, Pre ) \\ do_klass(RuntimeException_klass, java_lang_RuntimeException, Pre ) \\ do_klass(SecurityManager_klass, java_lang_SecurityManager, Pre ) \\ do_klass(ProtectionDomain_klass, java_security_ProtectionDomain, Pre ) \\ do_klass(AccessControlContext_klass, java_security_AccessControlContext, Pre ) \\ do_klass(ClassNotFoundException_klass, java_lang_ClassNotFoundException, Pre ) \\ do_klass(NoClassDefFoundError_klass, java_lang_NoClassDefFoundError, Pre ) \\ do_klass(LinkageError_klass, java_lang_LinkageError, Pre ) \\ do_klass(ClassCastException_klass, java_lang_ClassCastException, Pre ) \\ do_klass(ArrayStoreException_klass, java_lang_ArrayStoreException, Pre ) \\ do_klass(VirtualMachineError_klass, java_lang_VirtualMachineError, Pre ) \\ do_klass(OutOfMemoryError_klass, java_lang_OutOfMemoryError, Pre ) \\ do_klass(StackOverflowError_klass, java_lang_StackOverflowError, Pre ) \\ do_klass(IllegalMonitorStateException_klass, java_lang_IllegalMonitorStateException, Pre ) \\ do_klass(Reference_klass, java_lang_ref_Reference, Pre ) \\ \\ /* Preload ref klasses and set reference types */ \\ do_klass(SoftReference_klass, java_lang_ref_SoftReference, Pre ) \\ do_klass(WeakReference_klass, java_lang_ref_WeakReference, Pre ) \\ do_klass(FinalReference_klass, java_lang_ref_FinalReference, Pre ) \\ do_klass(PhantomReference_klass, java_lang_ref_PhantomReference, Pre ) \\ // ... hotspot/src/share/vm/classfile/systemDictionary.cppsystemDictionary.cpp123456789101112void SystemDictionary::initialize_preloaded_classes(TRAPS) { // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK); // ... Universe::initialize_basic_type_mirrors(CHECK); // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);. // ... initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK); // ... initialize_wk_klasses_until(WKID_LIMIT, scan, CHECK);} SystemClassLoader除了 Bootstrap ClassLoader 之外的类加载器都是在 Java 代码里面定义的，系统类加载器 ClassLoader.getSystemClassLoader() java.lang.ClassLoader123456789101112131415161718192021222324252627282930313233343536public abstract class ClassLoader { // ... // The class loader for the system // @GuardedBy(&quot;ClassLoader.class&quot;) private static ClassLoader scl; // Set to true once the system class loader has been set // @GuardedBy(&quot;ClassLoader.class&quot;) private static boolean sclSet; // ... @CallerSensitive public static ClassLoader getSystemClassLoader() { initSystemClassLoader(); if (scl == null) { return null; } SecurityManager sm = System.getSecurityManager(); if (sm != null) { checkClassLoaderPermission(scl, Reflection.getCallerClass()); } return scl; } private static synchronized void initSystemClassLoader() { if (!sclSet) { if (scl != null) throw new IllegalStateException(&quot;recursive invocation&quot;); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); // ... sclSet = true; } }} sun.misc.Launcher12345678910111213141516171819202122232425public class Launcher { // ... public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError(&quot;Could not create extension class loader&quot;, e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError(&quot;Could not create application class loader&quot;, e); } // Also set the context class loader for the primordial thread. Thread.currentThread().setContextClassLoader(loader); // ... }} 同时可以看到 AppClassLoader 的 parent 是 ExtClassLoader，同时 SystemClassLoader 也是在 JVM 初始化的时候进行初始化的 hotspot/src/share/vm/classfile/systemDictionary.cppsystemDictionary.cpp1234567891011void SystemDictionary::compute_java_system_loader(TRAPS) { KlassHandle system_klass(THREAD, WK_KLASS(ClassLoader_klass)); JavaValue result(T_OBJECT); JavaCalls::call_static(&amp;result, KlassHandle(THREAD, WK_KLASS(ClassLoader_klass)), vmSymbols::getSystemClassLoader_name(), vmSymbols::void_classloader_signature(), CHECK); _java_system_loader = (oop)result.get_jobject();} MainClass 的加载jdk/src/share/bin/java.cjava.c12345678910111213141516171819202122232425262728int JNICALL JavaMain(void * _args){ // ... mainClass = LoadMainClass(env, mode, what); // ... mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); // ... /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); // ...}static jclass LoadMainClass(JNIEnv *env, int mode, char *name){ // ... jclass cls = GetLauncherHelperClass(env); // ... // sun.launcher.LauncherHelper#checkAndLoadMain NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;checkAndLoadMain&quot;, &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;)); str = NewPlatformString(env, name); result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid, USE_STDERR, mode, str); // ... return (jclass)result;} sun.launcher.LauncherHelper123456789101112public enum LauncherHelper { private static final ClassLoader scloader = ClassLoader.getSystemClassLoader(); public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr, int mode, String what) { // ... mainClass = scloader.loadClass(cn); // ... return mainClass; }} 因此 MainClass 是由 ClassLoader.getSystemClassLoader() 加载的 一些结论 从 hotspot 的角度来讲，所有类都是通过 Klass 对象来描述的 类是一个抽象的概念 Object.class != Object 类，可以说 Object.class 也是一个对象，是用来表示底层（C++）Klass 的一个对象 一定是先有类，才有对象。一切都是对象，都继承自java.lang.Object（除了基本类型） 在 JVM 加载的过程中，会预先初始化一些 Klass 对象（well known classes），来描述具体的类 最早加载的几个类（按照顺序）java.lang.Object , java.lang.String , java.lang.Class , 9 个基本类型（包含 Void.TYPE）, java.lang.Cloneable , java.lang.ClassLoader 这些类是预加载，不需要有一个 java.lang.ClassLoader 的实例来加载，这个时候 JVM 都没有完全初始化 默认会有三个 ClassLoader，Bootstrap ClassLoader 是 C++实现的 Class.class.getClassLoader() == null （Bootstrap ClassLoader 在 Java 层面就是 null） 主类的 ClassLoader 就是 ClassLoader.getSystemClassLoader() Bootstrap ClassLoader 的存在是一个比较自然的事情，不需要死记硬背。 下面语句分别输出什么？ 12345678910public class Test { public static void main(String[] args) { System.out.println(Test.class.getClassLoader()); System.out.println(javax.sql.DataSource.class.getClassLoader()); System.out.println(String.class.getClassLoader()); System.out.println(ClassLoader.getSystemClassLoader()); System.out.println(ClassLoader.getSystemClassLoader().getParent()); System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); }} 可以自己试一下，不同版本会有差异。 类的加载、链接、初始化通过类的全名（binary name）获取二进制流加载到 JVM，并生成一个 java.lang.Class 对象表示这个类。 图片来源于网络 来看一下 Java 虚拟机规范关于类加载的描述 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html How the Java Launcher Finds Classes The Java launcher, java, initiates the Java virtual machine. The virtual machine searches for and loads classes in this order: Bootstrap classes - Classes that comprise the Java platform, including the classes in rt.jar and several other important jar files. Extension classes - Classes that use the Java Extension mechanism. These are bundled as .jar files located in the extensions directory. User classes - Classes defined by developers and third parties that do not take advantage of the extension mechanism. 现在我们知道，系统启动的时候，一共有三个 ClassLoader Bootstrap ClassLoader (C++ null) ExtClassLoader (SystemDictionary::compute_java_system_loader 时初始化) AppClassLoader (SystemDictionary::compute_java_system_loader 时初始化) 后续 ExtClassLoader 指 sun.misc.Launcher$ExtClassLoader 一个的实例，AppClassLoader 指 sun.misc.Launcher$AppClassLoader 的一个的实例 类型判断两个类型是否相等，是指全名（binary name）相等且是同一个类加载器完成加载的。包括兼容性判断 java.lang.Class.isAssignableFrom java.lang.Class.isInstance java.lang.Class.equals instanceof 关键字 类型转换 那么不同类加载器在加载同一个类的时候，应该如何处理 123456789101112131415public class Test { public static void main(String[] args) throws ClassNotFoundException { String name = &quot;java.lang.Object&quot;; Class&lt;?&gt; objectClass1 = Object.class; Class&lt;?&gt; objectClass2 = ClassLoader.getSystemClassLoader().loadClass(name); Class&lt;?&gt; objectClass3 = new URLClassLoader(new URL[0]).loadClass(name); objectClass2.isAssignableFrom(Test.class); objectClass3.isInstance(new Test()); objectClass1.getClassLoader(); // null objectClass2.getClassLoader(); // ? objectClass3.getClassLoader(); // ? }} 如果每个 ClassLoader 都去加载一遍 java.lang.Object 那么不同类加载加载的 Class 是不是相等的？如果不想等对象就没有办法相互转换，那么整个程序就会表现的很奇怪，从这个角度上讲 AppClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 AppClassLoader 去加载 Extension classes 也应该是由 ExtClassLoader 加载的 ExtClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 这就是一个委托（delegation）的模型。 双亲委派来看一下 ClassLoader 是如何加载一个类的https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance. 这个一般就称为双亲委派模型（Parent Delegation Model ）。 这个名词的翻译不好，“双”这个字不是很准确 java.lang.ClassLoader12345678910111213public abstract class ClassLoader { private static native void registerNatives(); static { registerNatives(); } // The parent class loader for delegation // Note: VM hardcoded the offset of this field, thus all new fields // must be added *after* it. private final ClassLoader parent; // ...} 其中 AppClassLoader 的 parent 是 ExtClassLoader，ExtClassLoader 的 parent 是 Bootstrap ClassLoader（null），这个跟之前的理解是一致的 AppClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 AppClassLoader 去加载 Extension classes 也应该是由 ExtClassLoader 加载的 ExtClassLoader 去加载 Bootstrap classes 也应该是由 Bootstrap ClassLoader 加载的 加载类对应的方法https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#loadClass-java.lang.String-boolean- java.lang.ClassLoader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class ClassLoader { // ... protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. // ... c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } // ... /** * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;. * This method should be overridden by class loader implementations that * follow the delegation model for loading classes, and will be invoked by * the {@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;} method after checking the * parent class loader for the requested class. The default implementation * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;. */ protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } // ...} 图片来源于网络 从上面的代码来看，双亲委派的实现时非常简单的。那为什么需要双亲委派？总感觉这个问题不是很好回答，因为从上面的分析来看，如果是这个 ClassLoader 的模型，那么双亲委派就是比较自然的方案 保证类的唯一性 避免重复加载 安全，核心类不会被篡改（比如 -classpath 中包含 java.lang.Object，但委托给 Bootstrap ClassLoader 之后就只能加载默认的类） 为了保证安全性，java. 开头的类是不能去定义的（例如在 -classpath 中包含 java.lang.Object2） java.lang.ClassLoader1234567891011private ProtectionDomain preDefineClass(String name, ProtectionDomain pd){ // ... // relies on the fact that spoofing is impossible if a class has a name // of the form &quot;java.*&quot; if ((name != null) &amp;&amp; name.startsWith(&quot;java.&quot;)) { throw new SecurityException(&quot;Prohibited package name: &quot; + name.substring(0, name.lastIndexOf('.'))); } // ...} 这里有对上述过程更详细的解释https://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc5.html SPI 与 ContextClassLoader我们来看一下 SPI 12345678public class Test { public static void main(String[] args) { Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mysql&quot;, &quot;root&quot;, &quot;123456&quot;); System.out.println(conn.getClass() == com.mysql.cj.jdbc.ConnectionImpl.class); System.out.println(com.mysql.cj.jdbc.ConnectionImpl.class.getClassLoader()); System.out.println(DriverManager.class.getClassLoader()); }} 可能这里看上去没有什么问题，但是 DriverManager 是 Bootstrap ClassLoader 加载的，最终 ConnectionImpl 是应用自己的 classpath 下，是 AppClassLoader 加载的。 那能不能写死 SPI 就用 java.lang.ClassLoader.getSystemClassLoader() 来加载呢？ 来看一下 DriverManager 是如何加载具体 Driver 实现的 java.sql.DriverManager12345678910111213141516public class DriverManager { // ... static { loadInitialDrivers(); } // ... private static void loadInitialDrivers() { // ... // SPI ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); // ... }} java.util.ServiceLoader12345678public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt; { // ... public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } // ...} 解决这个问题是通过线程上下文类加载器 Thread.currentThread().getContextClassLoader() ，每个线程绑定一个类加载器 12345Thread.currentThread().setContextClassLoader(classloader1)ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);Thread.currentThread().setContextClassLoader(classloader2)ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); ContextClassLoader 并不是一个优雅的设计，不过一般在代码中很少需要关注。主要使用场景是各种框架，框架利用上下文加载器加载对应的资源或者类。 双亲委派机制的破坏双亲委派的核心就是 parent 属性和 loadClass 方法 java.lang.ClassLoader1protected Class&lt;?&gt; loadClass(String name, boolean resolve) protected 说明这个方法是可以覆盖的，因此双亲委派不是强制的，肯定有一些场景是可以改写这个逻辑的。 一般认为 SPI 是破坏了双亲委派机制的（委派给另外一个上下文 ClassLoader 而不 parent），此外就是覆盖 loadClass 方法破坏双亲委派的机制，具体的使用场景后面会讲。 类的初始化时机https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html Initialization of a class or interface consists of executing its class or interface initialization method (§2.9). A class or interface C may be initialized only as a result of: The execution of any one of the Java Virtual Machine instructions new, getstatic, putstatic, or invokestatic that references C (§new, §getstatic, §putstatic, §invokestatic). These instructions reference a class or interface directly or indirectly through either a field reference or a method reference.Upon execution of a new instruction, the referenced class is initialized if it has not been initialized already.Upon execution of a getstatic, putstatic, or invokestatic instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already. The first invocation of a java.lang.invoke.MethodHandle instance which was the result of method handle resolution (§5.4.3.5) for a method handle of kind 2 (REF_getStatic), 4 (REF_putStatic), 6 (REF_invokeStatic), or 8 (REF_newInvokeSpecial).This implies that the class of a bootstrap method is initialized when the bootstrap method is invoked for an invokedynamic instruction (§invokedynamic), as part of the continuing resolution of the call site specifier. Invocation of certain reflective methods in the class library (§2.12), for example, in class Class or in package java.lang.reflect. If C is a class, the initialization of one of its subclasses. If C is an interface that declares a non-abstract, non-static method, the initialization of a class that implements C directly or indirectly. If C is a class, its designation as the initial class at Java Virtual Machine startup (§5.2). 有且只有上述 6 种情况（且这个类没有被加载）会去加载一个类，简单来说 new 读取/修改静态变量（排除在常量池的）调用静态方法 动态语言支持 java.lang.invoke.MethodHandle 相关 class library 中的一些方法，例如 Class 和 ClassLoader 的部分方法、反射（java.lang.reflect）等 初始化类的某个子类的时候 初始化包含默认方法接口的某个实现类的 Java 启动类（main Class） 其中 4 和 5 可以统一成一个递归的描述，如果要初始化一个类，需要先初始化父类和包含 default 方法的接口。6 在实现的时候其实属于 3 的，是通过java.lang.ClassLoader.loadClass加载的（sun.launcher.LauncherHelper）。 类加载的相关异常类加载过程，需要进行验证，比如文件格式、JAVA 版本、final 约束、可访问性约束等，具体细节就不赘述了 同时还有一个有一个非常重要的异常 12345678910try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); }} catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader} 在双亲委派的过程中 parent 如果加载不了某个类，需要抛出 java.lang.ClassNotFoundException（这里只 catch 了这个异常）。 public class ClassNotFoundException extends ReflectiveOperationException Thrown when an application tries to load in a class through its string name using: The forName method in class Class. The findSystemClass method in class ClassLoader . The loadClass method in class ClassLoader.but no definition for the class with the specified name could be found. public class NoClassDefFoundError extends LinkageError Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found. java.lang.NoClassDefFoundError 是一个 Error，发生在实例化一个类的时候（类已经找到了），一般情况是这个类依赖的某些定义不存在，一般会出现在 jar 包的版本不兼容上。 类的卸载满足如下条件，则类会被卸载 该类的所有实例（包含子类的实例）都被回收 该类的 ClassLoader 不存在任何引用 该类的 Class 对象不存在任何引用（包括相关的 Method Field 等，无法通过反射访问） 注意默认的三个类加载对应的类是不会被卸载的（ClassLoader 会一直被引用）。 自定义 ClassLoader如何自定义 ClassLoader一般是继承 java.net.URLClassLoader 或者直接继承 java.lang.ClassLoader，然后覆盖 findClass 或 loadClass 方法 覆盖 findClass这种修改一般不破坏双亲委派，会修改查找类的逻辑，实现某些动态的逻辑。可以实现但不限于以下的逻辑 从网络获取 从特定目录获取 特定目录结构的压缩包 War 包 WEB-INF SpringBoot FatJar 对二进制流做预处理，例如解密或验证签名 内存直接定义 Class 文件（配合字节码的库）（动态代理） 实现热加载 类似 JSP 的技术 … 覆盖 loadClass一般是修改类加载的层级结构，可以实现但不限于以下的逻辑 模块化 自定义某种类隔离的机制，例如 Tomcat … 当然上面两种也可以进行组合 应用场景SpringBootspring boot 应用打包之后可以直接通过 java -jar 命令启动 。 实现原理是 spring-boot-maven-plugin 在构建（repackage）的时候，会通过 org.springframework.boot.maven.RepackageMojo 打包成特定结构的 Jar 包https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.layers org.springframework.boot.loader.tools.Layouts.Jar12345678910111213141516171819202122232425262728293031/** * Executable JAR layout. */public static class Jar implements RepackagingLayout { @Override public String getLauncherClassName() { return &quot;org.springframework.boot.loader.JarLauncher&quot;; } @Override public String getLibraryDestination(String libraryName, LibraryScope scope) { return &quot;BOOT-INF/lib/&quot;; } @Override public String getClassesLocation() { return &quot;&quot;; } @Override public String getRepackagedClassesLocation() { return &quot;BOOT-INF/classes/&quot;; } @Override public boolean isExecutable() { return true; } // ...} 可以找一个 spring boot 的 Fat Jar 解压看一下看看 1234567891011121314151617181920212223242526.├── BOOT-INF│ ├── classes│ │ ├── application.properties│ │ └── com│ │ └── example│ │ └── demo│ │ └── DemoApplication.class│ ├── classpath.idx│ ├── layers.idx│ └── lib│ ├── ...│ ├── spring-boot-2.5.4.jar│ ├── spring-boot-autoconfigure-2.5.4.jar│ ├── spring-context-5.3.9.jar│ └── spring-core-5.3.9.jar├── META-INF│ └── MANIFEST.MF└── org └── springframework └── boot └── loader ├── JarLauncher.class ├── LaunchedURLClassLoader.class ├── Launcher.class ├── ... java -jar 命令会在 MANIFEST.MF 里面找 Main-Class 来运行，看下 META-INF/MANIFEST.MF 文件内容 META-INF/MANIFEST.MF123456789101112Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: demoImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.example.demo.DemoApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher 那么是如何启动的呢？ org.springframework.boot.loader.JarLauncher1234567891011121314151617181920212223242526public class JarLauncher extends ExecutableArchiveLauncher { static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;; static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;; public JarLauncher() { } protected JarLauncher(Archive archive) { super(archive); } @Override protected boolean isNestedArchive(Archive.Entry entry) { if (entry.isDirectory()) { return entry.getName().equals(BOOT_INF_CLASSES); } return entry.getName().startsWith(BOOT_INF_LIB); } public static void main(String[] args) throws Exception { new JarLauncher().launch(args); } // ...} org.springframework.boot.loader.ExecutableArchiveLauncher123456789101112131415161718192021222324252627282930public abstract class ExecutableArchiveLauncher extends Launcher { // ... @Override protected String getMainClass() throws Exception { Manifest manifest = this.archive.getManifest(); String mainClass = null; if (manifest != null) { mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;); } if (mainClass == null) { throw new IllegalStateException(&quot;No 'Start-Class' manifest entry specified in &quot; + this); } return mainClass; } @Override protected List&lt;Archive&gt; getClassPathArchives() throws Exception { List&lt;Archive&gt; archives = new ArrayList&lt;Archive&gt;(this.archive.getNestedArchives(new EntryFilter() { @Override public boolean matches(Entry entry) { return isNestedArchive(entry); } })); postProcessClassPathArchives(archives); return archives; } // ...} org.springframework.boot.loader.Launcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class Launcher { /** * Launch the application. This method is the initial entry point that should be * called by a subclass {@code public static void main(String[] args)} method. * @param args the incoming arguments * @throws Exception if the application fails to launch */ protected void launch(String[] args) throws Exception { JarFile.registerUrlProtocolHandler(); ClassLoader classLoader = createClassLoader(getClassPathArchives()); launch(args, getMainClass(), classLoader); } /** * Create a classloader for the specified archives. * @param archives the archives * @return the classloader * @throws Exception if the classloader cannot be created */ protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception { List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(archives.size()); for (Archive archive : archives) { urls.add(archive.getUrl()); } return createClassLoader(urls.toArray(new URL[urls.size()])); } /** * Create a classloader for the specified URLs. * @param urls the URLs * @return the classloader * @throws Exception if the classloader cannot be created */ protected ClassLoader createClassLoader(URL[] urls) throws Exception { return new LaunchedURLClassLoader(urls, getClass().getClassLoader()); } /** * Launch the application given the archive file and a fully configured classloader. * @param args the incoming arguments * @param mainClass the main class to run * @param classLoader the classloader * @throws Exception if the launch fails */ protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception { Thread.currentThread().setContextClassLoader(classLoader); createMainMethodRunner(mainClass, args, classLoader).run(); } // ...} 因为是 Fat Jar 的模式（Jar in Jar），因此需要自己实现 LaunchedURLClassLoader 来定制类的查找逻辑。 TomcatTomcat 可以同时加载多个 web 应用，并且可以热加载，支持动态加载或者卸载 web 应用。大概的实现思路 Tomcat 自身的代码会有一个 ClassLoader Tomcat 为每个 Web 应用创建一个 org.apache.catalina.loader.WebappClassLoader 加载 Web 应用自己的类，且 parent 会指向 Tomcat 自身的类加载器 WebappClassLoader 加载的时候 会先通过 javaseClassLoader 加载，默认为 ClassLoader.getSystemClassLoader().getParent() 部分类会通过 parent 来进行加载，这样应用可以共享一些类的定义（例如 javax.servlet.* 和 org.apache.tomcat.*） 之后会加载 Web 应用目录下的类，因此可以实现不同应用之间的类是隔离的 上述过程会破坏双亲委派的模型。来看一下 Tomcat 的目录结构，webapps 目录下包含了所有的 Web 应用 12345678910111213141516171819202122.├── bin│ ├── ...│ ├── shutdown.sh│ └── startup.sh├── conf│ ├── ...│ ├── server.xml│ └── web.xml├── lib│ ├── ...│ ├── servlet-api.jar│ ├── tomcat-api.jar│ └── tomcat-websocket.jar├── logs├── webapps│ ├── ROOT│ ├── docs│ ├── examples│ ├── host-manager│ └── manager└── work Tomcat 文档关于 WebappClassLoaderBase.loadClass 的描述 https://tomcat.apache.org/tomcat-8.5-doc/api/org/apache/catalina/loader/WebappClassLoaderBase.html org.apache.catalina.loader.WebappClassLoaderBase12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public abstract class WebappClassLoaderBase extends URLClassLoader implements ... { // ... @Override public Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // ... // (0) Check our previously loaded local class cache // ... // (0.1) Check our previously loaded class cache // ... // 之前会判断是否已经加载过 // javaseLoader 默认就是 java.lang.ClassLoader.getSystemClassLoader().getParent() ClassLoader javaseLoader = getJavaseClassLoader(); boolean tryLoadingFromJavaseLoader; // 判断是否应该用 javaseLoader 加载 // ... // 通过 javaseLoader 加载 if (tryLoadingFromJavaseLoader) { try { clazz = javaseLoader.loadClass(name); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } } boolean delegateLoad = delegate || filter(name, true); // (1) Delegate to our parent if requested if (delegateLoad) { try { clazz = Class.forName(name, false, parent); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { // Ignore } } // (2) Search local repositories try { clazz = findClass(name); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } // (3) Delegate to parent unconditionally if (!delegateLoad) { try { clazz = Class.forName(name, false, parent); if (clazz != null) { // ... return clazz; } } catch (ClassNotFoundException e) { } } throw new ClassNotFoundException(name); } protected boolean filter(String name, boolean isClassName) { // ... if (name.startsWith(&quot;javax&quot;)) { /* 5 == length(&quot;javax&quot;) */ if (name.length() == 5) { return false; } ch = name.charAt(5); if (isClassName &amp;&amp; ch == '.') { /* 6 == length(&quot;javax.&quot;) */ if (name.startsWith(&quot;servlet.jsp.jstl.&quot;, 6)) { return false; } if (name.startsWith(&quot;el.&quot;, 6) || name.startsWith(&quot;servlet.&quot;, 6) || name.startsWith(&quot;websocket.&quot;, 6) || name.startsWith(&quot;security.auth.message.&quot;, 6)) { return true; } } // ... } // ... }} Tomcat ClassLoader 的层次结构 图片来源于网络 其他动态语言，例如 groovy.lang.GroovyClassLoader依赖冲突隔离 https://www.zhihu.com/question/46719811/answer/1739289578 。OSGI 模块化，后来 Java 标准也引入了的模块化。热加载也可以用多个 ClassLoader 来处理（IDEA 重新加载类，不是通过 ClassLoader 实现的）。 ClassLoader 问题排查思路在遇到 ClassLoader 相关问题的时候，可以试试如下的思路（一般在有多个 ClassLoader 的时候） object.getClass().getClassLoader() / clazz.getClassLoader() 查看某个类的 ClassLoader，判断是否符合预期 Thread.currentThread().getContextClassLoader() 获取当前线程上下文 ClassLoader，判断是否符合预期 在遇到类加载相关错误，要能想到可能是 ClassLoader 不对 在使用框架的时候，如果遇到类加载相关错误，要想到可能是 ContextClassLoader 不对 object.getClass().getProtectionDomain().getCodeSource() / clazz.getProtectionDomain().getCodeSource() 可以查看某个类加载的路径（如果两个 Jar 包都有相同的类，可以看到最终是加载了哪个 Jar 包的类），判断是否符合预期 能通过 arthas 类和类加载相关的命令（sc，classloader，jad 等）来排查问题 在修改 contextClassLoader 的时候，要注意恢复上下文，可以参考如下代码 12345678ClassLoader classLoader;ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();try { Thread.currentThread().setContextClassLoader(classLoader); // ...} finally { Thread.currentThread().setContextClassLoader(contextClassLoader);} 补充：oop klass 模型上面提到，在 hotspot 代码里面 Klass 是类的底层实现，类加载最终的结果就是创建一个 Klass 对象，oop 是描述对象各种信息的指针，oop klass 模型是 JVM（hotspot）内非常核心的模型。 hotspot/src/share/vm/oops/klass.hppklass.hpp12345678// A Klass provides:// 1: language level class object (method dictionary etc.)// 2: provide vm dispatch behavior for the object// Both functions are combined into one C++ class.// ...class Klass : public Metadata { // ...} 图片来源于网络 在 C++层面有多个不同的类来描述这个体系，oop klass 模型这部分内容有兴趣可以自行搜索。 基本类型int.class 和 java.lang.Integer.class 是不同的，int.class == java.lang.Integer.TYPE。基本类型的值本质上来说不是 oop（也没有类型指针），所以 int.class 更像是 JVM 类型系统的一个特例（create_basic_type_mirror 从名字也能看出来），这些类型也是在 JVM 初始化过程中进行加载的（SystemDictionary::initialize_preloaded_classes）。 hotspot/src/share/vm/memory/universe.cppuniverse.cpp12345678910111213141516171819202122232425262728293031void Universe::initialize_basic_type_mirrors(TRAPS) { assert(_int_mirror==NULL, &quot;basic type mirrors already initialized&quot;); _int_mirror = java_lang_Class::create_basic_type_mirror(&quot;int&quot;, T_INT, CHECK); _float_mirror = java_lang_Class::create_basic_type_mirror(&quot;float&quot;, T_FLOAT, CHECK); _double_mirror = java_lang_Class::create_basic_type_mirror(&quot;double&quot;, T_DOUBLE, CHECK); _byte_mirror = java_lang_Class::create_basic_type_mirror(&quot;byte&quot;, T_BYTE, CHECK); _bool_mirror = java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK); _char_mirror = java_lang_Class::create_basic_type_mirror(&quot;char&quot;, T_CHAR, CHECK); _long_mirror = java_lang_Class::create_basic_type_mirror(&quot;long&quot;, T_LONG, CHECK); _short_mirror = java_lang_Class::create_basic_type_mirror(&quot;short&quot;, T_SHORT, CHECK); _void_mirror = java_lang_Class::create_basic_type_mirror(&quot;void&quot;, T_VOID, CHECK); _mirrors[T_INT] = _int_mirror; _mirrors[T_FLOAT] = _float_mirror; _mirrors[T_DOUBLE] = _double_mirror; _mirrors[T_BYTE] = _byte_mirror; _mirrors[T_BOOLEAN] = _bool_mirror; _mirrors[T_CHAR] = _char_mirror; _mirrors[T_LONG] = _long_mirror; _mirrors[T_SHORT] = _short_mirror; _mirrors[T_VOID] = _void_mirror;} 数组类型需要注意的是数组是 JVM 内部直接生成的，是一个特殊的类型（ArrayKlass）。在定义 SomeClass[] array = new SomeClass[1] 时并不会导致 SomeClass 类的初始化。数组也是 JVM 类型系统的特例。 补充：Java 标准模块化（Java 9+）在引入模块化之后，整个类加载机制会有一些变化，后面会单独写一遍文章来讲解。 参考https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.htmlhttps://hg.openjdk.java.net/jdk8https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.htmlhttps://docs.oracle.com/javase/8/docs/technotes/guides/security/spec/security-spec.doc5.html《深入理解 Java 虚拟机》https://www.cnblogs.com/mazhimazhi/","link":"/2021/09/java-classloader/"},{"title":"Valhalla (0): 序言","text":"在 JDK 1.8 中，增加了 java.util.Optional、java.time.LocalDateTime 等类，在这些类的注释中有这么一行： This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided. 引入了一个新的概念，基于值（value-based）的类。 在 JDK 16 的新特性中，还有一个不太起眼的 JEP 390: Warnings for Value-Based Classes。只是对基于值的类增加了一些警告信息，对功能没有任何影响。 可就在这个不起眼的概念背后，却跟一个足以颠覆 Java 的项目有关，这个项目就是 Valhalla。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects Valhallahttps://openjdk.java.net/projects/valhalla/ 在 OpenJDK 中有一些很重要的项目比如 Amber Loom Panama Valhalla 等。相当于是 OpenJDK 的分支，进行一些探索，这些项目带来的改动最终有可能会合并到正式版本的 JDK。 Valhalla 项目在 14 年就启动了，就两个目标： Value Types（值类型） Generic Specialization（特化泛型） JEPs目前已经发布的 JEP: JEP 390 Warnings for Value-Based Classes 候选状态（Candidate）的 JEP： JEP 218: Generics over Primitive Types JEP 401 Primitive Objects (Preview) JEP 402 Unify the Basic Primitives with Objects (Preview) 候选意味着很有可能在近期的版本加入预览 还有草稿状态的 JEP： JEP draft: Universal Generics (Preview) JEP draft: Value Objects (Preview) 设计文档背景 Background: How We Got the Generics We Have 现状 The State of Valhalla The Road to Valhalla The Language Model The JVM Model 为什么会颠覆 Java未来会出现如下颠覆性的代码： 1234567891011// 目前 new 的对象一定是不相等的assert new Point() == new Point();// 基本类型的泛型List&lt;int&gt; ints = new ArrayList&lt;&gt;();// 数组协变，目前的数组是不变的Object[] array = new int[0];// 目前 true 不是对象assert true instanceof Boolean;true.toString();// 目前 new 一个实例，getClass 一定是 类名.classassert new Point().getClass() != Point.class; 同时有如下颠覆性改变： 所有值都是对象（包括 int、double 等） 不是所有的对象都保存在堆中 （可能）Arrays 等只需要一组 sort 方法了（以前 int[] double[] 都有自己的 sort 方法） （可能）java.lang.Object 会变成抽象类，但是可以继续 new Object() 翻译约定后面有很多内容是翻译的，会按照如下约定： 英语 中文 说明 Bsic Primitive Type 基本类型 Primitive Data Type 基本类型 同基本数据类型/原始类型 Reference Type 引用类型 Value Type 值类型 Basic Primitive Value 基本值 Reference Value 引用值 Identity 指“有唯一标识的”，后续不做翻译 Identity-free 指“没有唯一标识的”，后续不做翻译 Identity-related Behavior Identity 相关操作 Identity-sensitive Operation Identity 相关操作 Primitive Wrapper Class 包装类 Primitive Object 原始对象 Primitive Classe 原始类 Identity Object Identity 类 Identity Classe Identity 对象 Primitive Value Type 原始值类型 Primitive Reference Type 原始引用类型 Reference-favoring Primitive Classe 引用优先的原始类 概念解释Type有这么几个跟类型相关的概念 值（Value）：在 Java 中有基本值和引用值。 类型（Type）：描述值和可执行操作的集合，每一个值对应一个类型。在 Java 中有值类型和引用类型，一些语言还有指针类型。 类（Class）：一种具体的类型 class type，或指 class 的声明。 对象（Object）：类的实例。 类对象（Class Object）：特指 java.lang.Class 的实例，在运行时表示一个类。 为什么说 Class 是一种 Type，来看一下 Class 的定义（Class implements Type）： 1234public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement {} 除了类类型，还有 ParameterizedType、GenericArrayType 等类型，一般用在反射相关的 API。同时类型还有一个关联的概念类型系统，编译期也会有类型检查。 值和类型对应，类和对象对应，可以参考 java.lang.reflect.Type 的相关文档。总的来说类型是一个更加抽象的概念。 Value Type跟引用相反，数据直接存储在栈中，更像是一个盒子，包装了若干个值，这个概念可以参考 C 语言中的 struct。 Identity在面向对象的程序设计中，实例化一个对象之后，不管我们怎么修改它的状态（属性值），我们都说它还是同一个对象（虽然它变化了），因此有两种维度来比较一个对象，状态和 Identity。 Identity 就是唯一标识，在实现上可以被认为是在内存中的地址（不考虑 GC 的话）。 具体到 Java 的话 equals 方法用来比较对象的状态，== 和 != 用来比较对象的 Identity（通常我们说的是不是同一个对象），每个对象都有唯一的 Identity（这个概念可以参考 System.identityHashCode 这个方法），因此 12assert new Object() != new Object();assert new Integer(1) != new Integer(1); 那么 Identity-free/Identity-less 就是反过来的意思，例如基本类型就是 Identity-free 的，所以 1assert 1 == 1; 所以在目前版本的 Java 中，所有的引用类型都是 Identity 的、基本类型都是 Identity-free 的，不过我们一般不会这么去描述，但这个概念是非常重要的。 Identity 不太好翻译，后面就当形容词用了，指“有唯一标识的”，Identity-free 指“没有唯一标识的” 在 Java 中有一些对象，其实是不需要区分不同实例的，例如 Integer.valueOf(1000) 就表示的是 1000 这个数字，没必要区分这个 1000 和那个 1000。 LocalTime.of(10, 0) 就表示“早上 10 点”，区分不同“早上 10 点”的实例是没有意义的。如果有一个方法是 doSomeThing(LocalTime localTime) ，那么几乎所有的场景下，我传入不同实例的“早上 10 点”应该都是一样的行为。 不是说不能区分，而是说没意义，这里只解释 Identity 这个概念。 Value-Based Classeshttps://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html 这个概念最早在 java 8 就提出了https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html 在上面的讨论中，我们发现有一些类型应该是 Identity-free 的，例如 java.lang.Integer 和 java.time.LocalTime，不应该去区分不同的实例。 再具体一点，满足下列规范的类被称为基于值的类（value-based classes） 所有的实例字段都是 final 的（不可变的，但可以包含引用并指向可变对象，例如 java.util.Optional）。 equals、hashCode 和 toString 的实现只依赖实例字段的值（包含引用的对象）而不是 Identity。 方法在处理相等的（equals）实例时行为是一致的（认为实例是可自由替换的（freely substitutable））。 实例不执行同步操作（synchronized）。 没有声明可访问的构造函数（可以包含废弃的）。 不提供任何可以生成独立 Identity 的对象创建机制： 简单来说就是任何方式创建的对象都是 Identity-free 的。 特别的，所有的工厂方法都必须保证，独立生成的两个实例如果 equals 那么一定 == 。 特别的，Object.clone() 应该返回相同 == 的对象。 是 final 的，父类（们）只能是 Object 或者没有字段、没有初始化代码、构造函数都是空的抽象类。 如果基于值的两个对象是相等的（equals），程序也不应该尝试去区分它们 不管是通过直接或间接的引用、使用 Identity hash、序列化等任何机制。 不应该执行同步操作（synchronized），因为没有办法保证独占对象监视器。 上述行为都是 Identity 相关的行为（Identity-related Behavior），在未来版本的 Java 中可能会变化，例如同步会失败。 目前基于值的类只是一种定义，为了后续版本更好的发展，在 JDK 16 中引入了新的 JEP 390: Warnings for Value-Based Classes，会对上述的一些行为进行警告。 只增加了警告信息，没有任何功能变化It does not make any changes to the Java Language or Java Virtual Machine specifications. Primitive Class and Primitive Objects基于值的类只是一个概念，任何一个类只要满足上述规范就是基于值的，目前并不会对实际写代码产生任何影响。 在 Valhalla 项目中引入一种新的类型，原始类（primitive class）(预览) 基于值的 Identity-free 因此在未来的 Java 代码中可能会出现 123primitive class Point {...}assert new Point() == new Point();assert new Point() == Point.default; 是不是感觉 Java 的底层逻辑都改变了，尤其是两个 new 出来的对象居然是 == 的，在基本类型和引用类型之间增加了一种新的类型。 Codes like a class, works like an int.（像 class 一样编写，像 int 一样运行）这里只解释新的概念，后面会进一步探讨为什么需要增加新的类型 在以前的草案中称为 “inline class” / “inline type” ，来看看目前最新的定义https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2020-October/001415.html 对象会细分成两种类型 Primitive Object 原始对象：是一种新的 Identity-free 的对象，相等、同步等相关操作的行为会有所不同 Identity Object：除了 Primitive Object 之外的对象（包括数组） 类型也会进行细分 Identity Class：实例是 Identity Object 的类。 Primitive Class 原始类（以前叫 Inline Class）：是一种特殊的类，它的实例是原始对象。类是 final 的，并且受到各种限制。非原始类要不然是 Identity Class 要不然是抽象类（或者是 java.lang.Object）。 Primitive Value Type 原始值类型（以前叫 Inline Type）：是一种类型，是值为原始对象（就是对象本身，而不是引用）。每一个原始类都有一个原始值类型，通常就是 类名 来表示。 Primitive Reference Type 原始引用类型：是一种类型，值为原始对象的引用或者 null。每一个原始类都有一个原始引用类型，通常就是 类名.ref 来表示。 Primitive Type：Primitive Value Type 或者 Primitive Reference Type。 Reference Type：仍然表示对象的引用或者 null（跟以前相同，强调包含了 Primitive Reference Type）。 类 Class / 类型 Type 是两个概念，参考上文。 在 Java 语言中，基本类型将（计划）变成原始对象，而用 java.lang.Integer 等作为它们的原始类。在需要的时候，可以使用内置的原始值类型（built-in primitive value type）指代它们的类型。 意味着，后面就没有基本类型了，只有原始对象和 Identity 对象，Java 将真正变成一切皆对象。int double 等含义会发生非常大的变化，但在使用上几乎没有变化。 这些概念有一些繁琐，我们来举一些例子 1234567891011121314java.lang.Integer.val.class // 原始类int.class // 原始类java.lang.Integer.class // 原始类java.lang.Object.class // 非原始类int.class 等价于 Integer.val.classjava.lang.Integer.val // 原始值类型java.lang.Integer // 原始引用类型int.ref // 原始引用类型int // 原始值类型（关键字）int.ref 等价于 Integerint 等价于 Integer.val","link":"/2021/10/valhalla/"},{"title":"Valhalla (1): 背景 How We Got the Generics We Have","text":"翻译 https://openjdk.java.net/projects/valhalla/design-notes/in-defense-of-erasure。 在我们讨论泛型该如何发展时，我们首先要看看当前泛型是什么样的。这篇文章主要聚焦在泛型是如何发展到现在的，以及为什么会是这个样子，了解这些可以帮助我们基于现有的泛型尝试构建出“更好”的泛型。 特别是，我们强调擦除实际上是 2004 年将泛型添加到 Java 时明智且务实的选择，而且很多导致我们选择擦除的因素至今仍在运作。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects 擦除 Erasure向任何开发人员询问 Java 泛型，你可能会得到关于擦除的负面情绪（虽然通常是不知情的）。擦除可能是 Java 中最广泛、最深入被误解的概念了。 擦除不是 Java 特有的，也不是泛型特有的，它是一种无处不在且必要的工具，用于将代码转换为较低级别的代码（例如从 Java 源代码编译为字节码，或将 C 源代码编译为本地代码）。这是因为当我们从高级语言转换到到中间表示再到本地代码再到硬件时，底层提供的类型抽象几乎总是比高层提供更弱更简单，这也是合理的（我们不想将虚拟分派的语义加入到 X86 指令集中，或者在其寄存器中支持 Java 的基本类型）。擦除是一种将更丰富的类型映射到较低级别的简单类型的技术（理想情况下，在更高级别执行完整的类型检查之后），这也是编译器的日常工作。 例如，Java 字节码包含在堆栈和局部变量（iload、istore）之间移动整数值的指令，以及对整数（iadd、imul 等）进行算术运算的指令。单精度浮点数（fload、fstore、fmul 等）、长整数（lload、lstore、lmul）、双精度浮点数（dload、dstore、dmul）和对象引用（aload、astore）都有类似的指令。但其他基本类型（byte、short、char 和 boolean）没有这样的指令，因为这些类型被编译器擦除为整数，并使用整数移动和算术指令。这是字节码指令集设计的权衡，它降低了指令集的复杂性，进而可以提高运行时的效率。Java 语言的许多其他特性（例如检查异常、方法重载、枚举、definite assignment analysis、内部类、通过 lambda 或局部类捕获局部变量等）是“语言错觉”，它们在 Java 编译器中检查，但在转换为类文件时被擦除了。 类似地，在将 C 编译为本机代码时，有符号和无符号整数都被擦除到通用寄存器中（没有单独的有符号寄存器和无符号寄存器），并且 const 变量存储在可变寄存器和可变的内存中。我们根本不觉得这种擦除很奇怪。 同构与异构翻译 Homogeneous vs. Heterogeneous Translations在具有参数多态性的语言中，翻译泛型类型有两种常用的方法：同构和异构翻译。在同构翻译中，泛型类 Foo&lt;T&gt; 被转换为单一的产物，例如 Foo.class （对于泛型方法也是如此）。在异构翻译中，泛型类型或方法的每个实例(Foo&lt;String&gt;、Foo&lt;Integer&gt;) 都被视为一个单独的实体，并生成独立的产物。例如，C++ 使用异构翻译，模板的不同实例是完全不同的类型，具有不同的语义和不同的生成代码。vector&lt;int&gt; 和 vector&lt;float&gt; 是不同的类型。一方面，这对于类型安全（每个实例可以在扩展后单独进行类型检查）和生成代码的质量（因为每个实例可以单独优化）非常有用。另一方面，这意味着更大的代码空间占用（因为 vector&lt;int&gt; 和 vector&lt;float&gt; 有独立的代码），我们不能谈论“某个东西的 vector”（就像 Java 通过通配符所做的那样），因为每个实例都是一个完整的不相关的类型。（作为对可能的占用空间成本的极端演示，Scala 试验了一个 @specialized 注解，当应用于类型变量时，会导致编译器为所有基本类型生成专门的版本。这听起来很酷，但导致生成类的数量随着类型变量的数量爆炸式增长，因此可以从几行代码轻松生成一个 100MB 的 JAR 文件。） 在同构和异构翻译之间的选择，涉及到语言设计者一直在进行的各种权衡。异构翻译提供了更多的类型特异性，但代价是更大的静态和动态开销，以及更少的运行时共享，所有这些都会对性能产生影响。同构翻译更适合抽象相似的参数类型，例如 Java 的通配符或 C# 的 declaration-site variance（C++ 缺少这两者，vector&lt;int&gt; 和 vector&lt;float&gt; 之间没有任何共同点）。有关翻译策略的更多信息，请参阅这篇有影响力的论文。 在 Java 中擦除泛型 Erased Generics in JavaJava 使用同构翻译来翻译泛型。泛型在编译时进行类型检查，但是在生成字节码时，像 List&lt;String&gt; 这样的泛型类型会被擦除到 List，而像 &lt;T extends Object&gt; 这样的类型变量会被擦除到它们的边界（在这种情况下就是 Object）。如果我们有： 123456789class Box&lt;T&gt; { private T t; public Box(T t) { this.t = t; } public Box&lt;T&gt; copy() { return new Box&lt;&gt;(t); } public T t() { return t; }} javac 编译器构建出一个单一的类文件 Box.class，作为 Box 的所有实例化的实现，包括通配符 (Box&lt;?&gt;) 和原始类型 (Box)。字段、方法、父类型的描述都被擦除，类型变量被擦除到它们的边界，泛型类型参数被擦除到它们的原始类型（List&lt;String&gt; 擦除到 List），如下所示： 123456789class Box { private Object t; public Box(Object t) { this.t = t; } public Box copy() { return new Box(t); } public Object t() { return t; }} 注：上面一段描述比较绕，指的是类型参数出现在不同的位置，例如： 12345678910111213class Demo&lt; F extends Number, M extends List&lt;F&gt;, S extends Serializable, E extends Object&gt; implements List&lt;S&gt; { private F field; private List&lt;E&gt; list; private S object; M t(M m) { return m; }} 被擦除为： 123456789class Demo implements List { private Number field; private List list; private Serializable object; List t(List m) { return m; }} 泛型签名会被保留在 Signature 属性中，以便编译器在读取类文件时可以看到泛型签名，但 JVM 在链接时仅使用擦除后的描述符。这种转换方案意味着在类文件级别，Box&lt;T&gt; 的布局和 API 都被擦除了。同样的事情也会发生在使用的时候，对 Box&lt;String&gt; 的引用被擦除到 Box，并且会插入到 String 的类型转换。例如： 12Box&lt;String&gt; box = new Box&lt;&gt;();String value = box.t(); 会被转换成： 12Box box = new Box();String value = (String)box.t(); 有没有替代方案 Why? What were the Alternatives?正是在这一点上，人们很容易生气并宣称这是愚蠢或懒惰的选择，或者说擦除是一种非常 hack 的行为。毕竟，为什么编译器会丢弃完美的类型信息呢？ 为了更好地理解这个问题，我们还应该问：我们是否要特化该类型信息，我们希望用它做什么，以及与之相关的成本是多少？我们可以设想几种不同的场景，需要使用特化的类型参数信息： 反射：对于某些人来说，“特化泛型”仅仅意味着可以知道 List 它是什么的列表，无论是使用诸如 instanceof 之类的语言特性或对类型变量进行模式匹配，还是使用反射库来查询类型参数。 特化 API 和布局：在有基本类型或者内联类的语言中，将 Pair&lt;int, int&gt; 布局扁平化成两个 int 会更好，而不是两个指向包装对象的引用。 运行时类型检查：当使用者尝试将 Integer 放入 List&lt;String&gt; 中时（例如，通过 List 原始类型引用），会导致内存污染。能够识别这类问题并失败，会比（可能的）后续再通过类型转换检测会更好。 把 Integer 放入 List&lt;String&gt; ，在后续不会读取的情况下，可能是不会出报错的。 虽然并不相互排斥，但这三种可能（反射、特化和类型检查）有助于实现不同的目标（分别是便利性、性能和安全性），并且具有不同的含义和成本。虽然说“我们想要特化”很容易，但如果深入研究，会发现，对于什么是最重要的、它们的成本和收益是什么，是存在巨大分歧的。 要了解擦除在这里是多么明智和务实的选择，我们还必须了解当时的目标、优先事项和限制以及替代方案。 逐步迁移兼容性 Goal: Gradual Migration CompatibilityJava 泛型定了一个雄心勃勃的要求：必须能够以二进制兼容和源代码兼容的方式将现有的非泛型类演化为泛型类。 这意味着现有的调用者和子类，比如 ArrayList，可以继续重新编译而不改变成泛型的 ArrayList&lt;T&gt;，并且现有的类文件将继续链接到泛型的 ArrayList&lt;T&gt; 的方法。满足上述要求，意味着调用者和泛化类的子类可以选择立即、稍后或永远不进行泛化，并且可以独立于其他调用者或子类的维护者的选择。 如果没有这个要求，生成一个类将需要一个“截止日期”，所有调用者和子类就算不修改，但至少必须重新编译。对于像 ArrayList 这样的核心类，这本质上要求重新编译世界上所有的 Java 代码（或永久降级保留在 Java 1.4 上）。因为整个 Java 生态中已经不存在这样的“截止日期”，所以我们需要一个泛型类型系统，允许核心平台类（以及流行的第三方库）被泛化，而不需要调用者知道它们被泛化。（更糟糕的是，它不会是一个确定的时间，因为世界上所有的代码都不可能在同一个时刻被泛型化） 另一种满足此要求的方式是：隔离所有可以被泛化的代码被认为是不可接受的，或者让开发人员在泛型之间进行选择并保留它们已有的代码。通过使泛化成为兼容操作，可以保留已有的代码，而不是废弃掉。 原文有点绕，感觉上是在说，可以单独设计一套 API（例如 GenericList&lt;T&gt; ），然后之前的 API 继续存在（例如只有 List 而不存在 List&lt;T&gt; ），这样开发人员可以自行选择，之前的代码都可以继续保留。 对“截止日期”的厌恶来自 Java 设计的一个基本原则：Java 是单独编译和动态链接的。单独编译是指将每个源文件编译成一个或多个类文件，而不是将一组源文件编译成单个产物。动态链接意味着类之间的引用在运行时基于符号信息链接的：如果类 C 在调用了 D 中 void m(int x) 方法，那么在 C 的类文件中我们记录了调用的方法的名称和描述符 (I)V，并在链接时在 D 中查找一个方法使用此名称和描述符，如果找到匹配项，则链接该调用。 这听起来像是非常巨大的工作，但是将编译和动态链接分开是 Java 的最大优势之一：可以针对一个版本的 D 编译 C，并在类路径上使用不同版本的 D 运行（只要不破坏二进制兼容性）。对动态链接的承诺允许我们简单地在类路径上放置一个新的 JAR 以更新到依赖项的新版本，而无需重新编译任何东西。 我们经常这样做，甚至都没有注意到。但是如果出现问题，它确实会被注意到。 在泛型被引入 Java 的时候，世界上已经有非常多的 Java 代码，它们的类文件中充满了对 java.util.ArrayList 等 API 的引用。如果我们不能兼容地泛化这些 API，那么我们将不得不编写新的 API 来替换它们。更糟糕的是，所有旧 API 的调用代码都将陷入一个站不住脚的选择：要么永远停留在 1.4，要么重写它们以同时使用新的 API（不仅包括应用程序代码，还包括应用程序依赖的所有第三方库）。这会影响当时几乎所有存在的 Java 代码。 C# 做出了相反的选择：更新他们的 VM，并使它们现有的库和所有依赖它的用户代码无效（需要升级到泛型）。当时他们可以这样做，因为世界上的 C# 代码相对较少，但 Java 当时没有这个选项。 然而这种选择的一个结果是，一个泛型类将同时拥有泛型和非泛型调用者或子类，这将是一种预期的情况。这对软件开发过程来说是一个福音（兼容），但在这种混合使用下对类型安全有潜在的影响。 内存污染 Heap Pollution以这种方式擦除，并支持泛型和非泛型调用者之间的相互操作，会产生内存污染的可能性：存储在 Box 中内容的运行时类型，与预期的编译时类型不兼容。 当调用者使用 Box&lt;String&gt; 时，会插入 T 到 String 的类型转换，所以在类型变量（Box 的实现）到具体类型转换的时候，内存污染会被检测出来。在存在堆污染的情况下，类型转换会失败。 内存污染可能来自非泛型代码使用泛型类，或者当我们使用未经检查的强制转换或原始类型，来伪造对错误泛型类型变量的引用时 （当我们使用未经检查的强制转换或原始类型时，编译器会发出警告），例如： 1234Box&lt;String&gt; bs = new Box&lt;&gt;(&quot;hi!&quot;); // safeBox&lt;?&gt; bq = bs; // safe, via subtypingBox&lt;Integer&gt; bi = (Box&lt;Integer&gt;) bq; // unchecked cast -- warning issuedInteger i = bi.get(); // ClassCastException in synthetic cast to Integer 这段代码的错误是从 Box&lt;?&gt; 到 Box&lt;Integer&gt; 的未经检查的转换：我们必须相信开发人员的说法，即指定的 Box 确实是 Box&lt;Integer&gt;。但是内存污染并没有立即被捕获，只有当我们尝试将 Box 中的字符串用作整数时，才会检测到出现问题。在同构翻译下，如果我们在将 Box 用作 Box&lt;String&gt; 之前将 Box&lt;Integer&gt; 转换成 Box&lt;String&gt;，不会发生任何事情（无论好坏）。但在异构翻译下，Box&lt;String&gt; 和 Box&lt;Integer&gt; 将具有不同的运行时类型，并且此转换将失败。 Java 语言实际上为泛型提供了相当强大的安全保证，只要我们遵循以下规则：如果程序编译时没有未检查或原始类型警告（不考虑反射之类的情况），则编译器插入的强制转换永远不会失败。 未检查警告：Unchecked cast: ‘…’ to ‘…’ 。原始类型警告：Raw use of parameterized class ‘…’ 。 换句话说，只有当我们与非泛型代码进行交互或对编译器撒谎时，才会发生内存污染。在发现内存污染时，我们会得到一个明确的异常（ClassCastException），告诉我们预期的类型和实际的类型。 JVM 生态 Context: Ecosystem of JVM Implementations and Languages围绕泛型的设计选择还受到 JVM 实现生态结构和在 JVM 上运行的语言结构的影响。虽然对大多数开发人员来说，“Java”是一个整体的概念，但实际上 Java 语言和 Java 虚拟机 (JVM) 是独立的实体，分别有自己的规范。 Java 编译器为 JVM 生成类文件（其格式和语义在 Java 虚拟机规范中列出），但是 JVM 会很乐意运行任何有效的类文件，而不管它最初来自什么源语言。据统计，有超过 200 种语言使用 JVM 作为编译目标，其中一些与 Java 语言（例如 Scala、Kotlin）有很多共同点，而另一些则是非常不同的语言（例如，JRuby、Jython、Jaskell）。 JVM 作为编译目标如此成功的一个原因（即使是与 Java 完全不同的语言），是它提供了一个相当抽象的计算模型，而受 Java 语言本身的影响有限（独立的规范）。语言和虚拟机之间的抽象层不仅激发了在 JVM 上运行的其他语言的生态，而且对 JVM 独立实现的生态也很有用。虽然今天的市场已经大幅整合，但在将泛型添加到 Java 时，有十多种商业上可行的 JVM 实现。将泛型特化意味着我们不仅需要增强语言以支持泛型，还需要增强 JVM。 虽然当时在技术上可以为 JVM 添加泛型支持，但这不仅是一项需要大量实现者之间协调的重大工程，而且 JVM 上的语言生态也可能有关于特化泛型的意见。例如，如果特化的解释执行包括运行时的类型检查，Scala（及它的 declaration-site variance）是否愿意让 JVM 强制执行 Java 中的（不变的）泛型子类型规则？ 擦除是务实的妥协 Erasure was the Pragmatic Compromise总之，这些限制（技术和生态）作为一股强大的力量推动我们走向同构翻译策略，即在编译时擦除泛型类型信息。 总而言之，推动我们做出这一决定的因素包括： 运行时成本。异构转换需要各种运行时成本：更大的静态和动态占用空间、更大的类加载成本、更大的 JIT 成本和代码缓存压力等。这可能使开发人员不得不在类型安全和性能之间做出选择。 迁移的兼容性。当时还没有已知的翻译方案允许迁移到特化的泛型，并保持源代码和二进制兼容，从而造成“截止日期”并使开发人员需要对大量现有代码进行改动。 还是运行时成本。如果将特化解释为在运行时检查类型（就像动态检查 Java 协变数组中的存储一样），这将对运行时产生重大影响，因为 JVM 必须在运行时对每个字段或数组元素存储时执行泛型子类型检查，使用语言的泛型类型系统。当类型像 List&lt;String&gt; 这样的简单类型时，这可能听起来既简单又成本低，但是当遇到像 Map&lt;? extends List&lt;? super Foo&gt;&gt;, ? super Set&lt;? extends Bar&gt;&gt; 这样的类型时会很快变得成本高昂。（事实上，后来的研究对泛型子类型的可判定性产生了怀疑） JVM 生态。能够让十几家 JVM 供应商就是否以及如何在运行时特化类型达成一致，是非常不现实的。 交付。即使有可能让十几个 JVM 供应商就一个实际可行的方案达成一致，也会大大增加复杂性、时间周期和风险，这是非常复杂且冒险的工作。 语言生态。像 Scala 这样的语言可能不乐意将 Java 的不变泛型融入 JVM 的语义中。就 JVM 中泛型跨语言可接受的语义达成一致，将再次增加复杂性、时间周期和风险，这是非常复杂且冒险的工作。 无论如何，用户都必须处理擦除（因此也必须处理内存污染）。即使可以在运行时保留类型信息，在类被泛化之前总是会编译出原始的类文件，因此堆中仍然可能存在没有任何附加类型信息的 ArrayList，一样有内存污染的风险。 某些有用的语句是无法表达的。当现有的泛型代码知道一些编译器不知道的运行时类型时，它偶尔会诉诸未经检查的强制转换，并且在泛型类型系统中没有简单的方法来表达它。许多这样的技术对于特化的泛型是不可能的，这意味着它们必须以不同的方式表达，而且通常成本更高。（没有明白具体说的是什么，可能指例如 instanceOf List 这样的判断） 很明显成本和风险是巨大的。那么会有什么好处？之前我们提到了特化的三个可能的好处：反射、布局特化和运行时类型检查。上述论点在很大程度上排除了我们进行运行时类型检查的可能性（运行时成本、不可判定性风险、生态风险以及原始类型实例的存在）。 能够知道 List 的元素类型是什么（也许可以知道，但也可能没有）当然会有一些好处。只是成本和收益相差了几个数量级。（同构翻译的另一个代价是不能支持基本类型作为类型参数，例如必须使用 List&lt;Integer&gt; 而不是 List&lt;int&gt;） 普遍认为擦除是不好的 hack 的误解，通常源于缺乏对替代方案的真实成本的认识，包括工程工作量、时间周期、交付风险、性能、生态影响和便利性，鉴于已经编写的大量 Java 代码以及在 JVM 上运行的 JVM 实现和语言的多样化生态。","link":"/2021/10/how-we-got-the-generics-we-have/"},{"title":"Valhalla (2): 现状 The Road to Valhalla","text":"通往 Valhalla 之路翻译 https://openjdk.java.net/projects/valhalla/design-notes/state-of-valhalla/01-background。 这是描述 Valhalla 现状（2021.12）的三篇文章中的第一篇，第二篇是语言模型，第三篇是 JVM 模型。 Valhalla 的口号是：像 class 一样编写，像 int 一样运行。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects 背景 BackgroundValhalla 项目始于 2014 年，其目标是为基于 JVM 的语言带来更灵活的扁平化的数据类型，以恢复编程模型与现代硬件性能特征之间的一致性。（某种程度上讲，它开始得更早，Java 的设计者希望在语言的初始版本中包含值类型） Valhalla 预计会向平台添加三个核心功能：值对象（value objects）、原始类（primitive classes）和特化泛型（specialized generics）。在项目的初始阶段，我们主要关注在理解语言和 JVM 该如何发展以支持这些功能，以及对用户代码迁移兼容性的影响。 虽然可以逐步发布这些功能，但在实现之前，有必要对它们如何协同工作有一个端到端的了解。我们展示了一种可行的路径，通过值类型（value classes）和原始类（primitive classes）增强 Java 语言和虚拟机，迁移现有的基本类型和基于值的类来利用这些特性，并允许基本类型和泛型进行无缝的交互。这一系列的文档总结了该路径，并会分阶段交付。其中前三个 JEP 是 JEP draft: Value Objects、JEP 401 和 JEP 402。（如果你想跟最开始的版本比较，请参阅我们的 2014 年的原始文件） 然而，Valhalla 项目不仅仅是关于它提供的功能，或者是性能的提升，它有更雄心勃勃的计划来统一基本类型和对象（真正做到一切皆对象）。 间接访问的代价 The Costs of IndirectionJVM 类型系统包括八种基本类型（int、long 等）、对象（具有 Identity 的异构聚合）和数组（具有 Identity 的同构聚合）。这组构建方式非常灵活，你可以对任何需要的数据结构进行建模。不能用基本类型表示的数据（例如复数、三维点、元组、定点数、字符串等）可以轻松地使用对象进行建模。但是，对象是在堆中分配的（除非 VM 可以证明它们的作用域足够窄且没有别名），需要一个对象头（通常是两个机器字长），并且必须通过内存间接引用。 例如，一个 XY 点对象数组具有以下内存布局： 在 1990 年代初期设计 Java 虚拟机时，内存获取数据的成本与计算操作（例如加法）的成本相当。随着当今 CPU 的多级内存缓存和指令级并行性，一次缓存 miss 的开销可能相当于 1000 次计算操作，相对成本的大幅增加了。 因此，JVM 偏好的指针布局（涉及小数据块之间的多次间接访问）不再是当今硬件上的理想选择。我们的目标是通过为 Java 开发人员提供更简单的途径来实现扁平（高效缓存）和密集（高效内存）的数据布局，而不会影响抽象或类型安全，从而使数据布局更适合当今硬件的性能模型。 我们想要的是有一个选项来获得更像这样的布局： 这种布局比以前的版本更扁平（没有间接访问）和更密集（没有对象头）。Valhalla 项目通过分离语义并允许用户控制，为我们提供了一种自然的方式来获得这种布局，而不必过分关注底层细节。 扁平化不仅与堆中的布局有关，我们还可以扁平化调用约定（calling convention），即 JVM 如何将值从一种方法传递到另一种方法（在堆栈上，或在寄存器中）。在没有特定的 JVM 优化的情况下，目前将一个 Point 传递给另一个方法时是通过传递指针，被调用者对该指针解引用以访问对象的状态。 我们想要一个更扁平的调用约定，其中可以通过按值传递 x 和 y 来传递 Point。在某些情况下，扁平化调用约定可以产生比堆扁平化布局更显着的性能改进。 非统一类型系统的代价 The Costs of a Split Type System作为面向对象的语言，基本类型和对象的分离体现了一个重大的妥协：面向对象的语言希望从“一切都是对象”的前提出发。但是，一个 int 不是一个对象，它是一种特殊而神奇的东西（它的数组也是如此），并且这种不统一性对整个语言、库和运行时都产生了重要的影响。 1995 年做出的妥协是，用户可以定义的一切都是对象，但是还有八种额外的内置类型不是对象，并且无法定义新的这样的类型。这在当时肯定是被迫的，尚不知道如何摆脱“一切都是对象”的束缚，但仍然希望提供合理的计算性能。当时看起来还不错，尽管如此，我们已经能够完成伟大的事情，但这是对开发人员、库设计人员和用户来说，是一个持续的技术债。 当泛型在 2004 年出现时，它变得稍微好一点，但也带来了更多的问题。变“好”的是支持了自动装箱（尽管重载解析的复杂性也付出了巨大的代价），所以我们可以自由地在需要整数的地方使用 int，反之亦然。但是，这只是解决了表面问题，而不是深层的的分歧。我们必须意识到基本类型和引用类型之间的分歧越来越多，因为基本类型不能用作泛型的类型参数。同样的，这是一种务实的妥协，也是当时已知的唯一一种在没有大规模兼容性问题的情况下向 Java 添加泛型的方法，但技术债只会越来越多。 当 2014 年 lambda 出现时，情况再次变得更糟。 Lambda 大量构建在泛型上，因此泛型面临的许多后果都被 lambda 继承了。这影响了库的设计，java.util.function 在特化版本时遇到了组合爆炸的问题（IntPredicate、IntToLongFunction），而不是能够参数化更通用的类型（Predicate&lt;int&gt;、Function&lt;int、long&gt;）。泛型的目标是抽象表示的差异，但基本类型和引用类型之间的鸿沟越来越难以弥合。 装箱的代价 The Costs of BoxingJava 八种内置的基本类型不是对象，但它们有包装类。当基本类型想要在对象世界中交互时，我们透明地将它们转换为对应的包装类，或者反过来。基本类型没有实现像 Comparable 那样实现接口，不过他们的包装类实现了。Object 是最顶级类型，但仅适用于类。因此基本类型不能直接参与泛型或动态类型库，例如反射（其中一切都表示为 Object 或 Object[]），它们只能通过包装类来做到这一点。 通过装箱不一定是坏事，ArrayList&lt;Integer&gt; 的含义已经很清楚了，自动装箱让我们可以用一种语法上方便的方式来处理这些类型。但同时带来了很多问题。包装类有 Identity，而基本类型没有，包装无法完全弥补这一差距。每次我们从 Integer 转换为 int 时，Identity 都会丢失，每次我们从 int 转换为 Integer 时，都会创建一个新的（但是非预期的）Identity（这会阻止有价值的运行时优化）。虽然 int 可以装箱为 Integer，但 int[] 不会装箱为 Integer[]。并且基本类型与其对应的包装类型之间的关系完全是临时的。你需要记住上述这些差异。 开发者知道装箱不仅不合常规，而且还有一定的开销。如果没有足够的优化，装箱转换需要分配堆内存，并且使用装箱类作为字段需要间接访问。装箱类有与我们在上面看到的 Point 有相同的问题，只是有效载荷较小（只有一个字段）。 不断增加的成本 And the Costs Roll On在库的级别，开发人员面临更困难的选择。最基本的库（集合和流）是库设计者必须进行权衡的主要例子。集合（collection）合理地选择了避免特化（Java 生态中有一些库，例如 trove 或 Eclipse Collections，它们走另一条路，这也很好），不过流（stream）走上了一条试图通过手动特化（int、long 和 double）的路线，但 IntStream 的存在证明了库设计者经常不得不将自己绕进去。更糟糕的是，手动特化带来了更多的手动特化（IntStream 产生了 IntToLongFunction 和 PrimitiveIterator.OfInt），并且总是有人要求更多（“我的 CharStream 在哪里”）。手动特化几乎总是会引入不对称。最后，手动特化流类型的存在成为该库设计和实现的重大限制。 库设计者经常面临良好的内存行为和良好的抽象之间的错误选择。 用户有的时候也必须要面对基本类型和包装类之间的差异。几乎每个 Java 开发人员都编写临时的、手动实现的 ArrayList&lt;int&gt; 的等价物，因为 ArrayList&lt;Integer&gt; 不够（或被认为不够）适合这种情况。 而且这个手动实现很少与 List 有任何联系，这抑制了互操作性并进一步影响了任何想要使用它的 API。 良好的内存行为和良好的抽象之间的权衡对用户和库设计者来说一样艰难。 根本原因 The Root Cause上面 Point[] 的不合理布局源自对象 Identity，所有对象实例都是唯一标识的。Identity 使可变性成为可能。为了改变对象的字段，我们必须知道我们要修改哪个对象。Identity 还支持布局多态性，其中子类与其超类共享一个公共布局前缀，从而允许通过超类引用安全地操作子类实例。即使对于避免可变性和布局多态性的类（包括大多数不可变的具体类），Identity 仍然可以通过各种 Identity 相关的操作来观察，包括对象相等（==）、同步、System::identityHashCode、弱引用等。 Identity 有效地要求一个对象恰好位于一个地方，如果我们想访问它，我们就去源头。这就是 Point[] 布局充满指针的原因，数组元素只是对实际对象的引用。并且 Identity 要求 VM 悲观地保留 Identity，以防有人最终可能执行 Identity 相关的操作，从而抑制许多有用的优化。在 90 年代初期，“一切都是对象”是一个很有吸引力的口头禅，Identity 的性能成本在当时似乎并不繁重，但随着时间的推移，这个成本越来越高。 Valhalla 的基本特征是某些类可能不需要他们的 Identity。一个没有 Identity 的对象是一个值对象，它的类是一个值类型。这些类放弃了一些灵活性，例如它们必须是不可变的，不能是布局多态的。但作为回报，它们会获得更好的性能。没有 Identity 允许 JVM 自由复制和重新编码这些对象，只保留它们的状态并需要更少的间接访问。 尽管对可变性和子类化有限制，但值类型可以使用类可用的大多数机制，方法、构造函数、字段、封装、接口、泛型、注解等。 此外，某些值类型可能会选择表示为原始类。 原始型不能为空，并且封装性不如引用类型。但它们的值是实例字段的值本身的序列，最大限度地提高了 JVM 实现扁平、密集的内存布局和优化调用约定的能力。这些所谓的原始类可以将类的表达能力与基本类型的运行时行为结合起来。Valhalla 的口号是：像 class 一样编写，像 int 一样运行。 Codes like a class, works like an int. 与基本类型（int、double 等）不同，通过类声明的基本类型具有字段和方法，它们的值可以根据需要自由转换为值对象，而没有装箱的开销和临时性。它们的数组可以被视为对象数组。 每个级别的程序都会用到原始类和基本类。除了显而易见的将内置基本类型转化为真正的类，许多 API 抽象，例如数字、日期、游标和 Optional 之类的包装类，都可以自然地建模为值类或原始类。此外，许多数据结构可以在其实现中使用原始类来提高效率。同时语言编译器可以将它们用作内置数字类型、元组或多返回等功能的编译目标。 那么泛型呢 What about Generics?Java 泛型的早期妥协之一是泛型类型变量只能用引用类型实例化，不能用基本类型实例化。这既不方便（当我们想用 List&lt;int&gt; 时我们不得不用 List&lt;Integer&gt;）成本又高（装箱有性能开销）。对于八种基本类型，我们学会了接受这种限制，但是如果我们可以编写自己的可扁平化的数据类型，例如上面的 Point，那么让 ArrayList&lt;Point&gt; 不受 Point 扁平化数组的支持似乎是不应该的，这是重点。 参数多态总是需要在代码占用、抽象和特化之间进行权衡，不同的语言选择了不同的权衡。一方面，C++ 为模板的每个实例化创建一个专门的类，不同的特化彼此之间没有类型系统的关系。这种异构翻译提供了高度的特化，但需要大量的代码空间占用以及抽象的损失，没有和 Java 中 List&lt;?&gt; 等效的类型（不能定义一个 vector&lt;?&gt; 或者 vector）。 另一方面，我们有 Java 当前的擦除实现，它为所有引用实例化生成一个类，并且不支持基本类型实例化。这种同构的翻译产生了高度的重用，因为所有（引用）实例化只有一个类和一个对象布局。它带有一个限制，即我们只能对具有公共运行时表示的类型进行处理，这在 Java 中是所有的引用类型。这种限制深深植根于 JVM 的设计中，对引用值和基本值的操作有不同的字节码。 虽然大多数开发人员对擦除有一定程度的厌恶，但这种方法有一个强大的优势，我们无法通过其他方式获得：逐步迁移兼容性。这是将类从非泛型兼容地演变为泛型的能力，而不会破坏现有的源代码或二进制类文件，并使调用者和子类具有立即、稍后或永不迁移的灵活性。向用户提供泛型，但以丢弃他们已有的代码为代价，在 2004 年将是一个糟糕的决定，当时 Java 已经拥有庞大而充满活力的安装基础。如果今天选择不兼容，将是一个更糟糕的决定。 泛型计划有两个阶段：通用泛型和特化泛型。在第一阶段，我们修复了阻止我们使用基本类型作为泛型类型参数的语言级别的限制，允许泛型覆盖所有类型，但仍然通过擦除实现。（这产生了一种更统一和更具表现力的语言，但还没有优化性能，尽管一些装箱成本已经被更轻量级的值对象转换所取代）在第二阶段，我们在 JVM 中启用布局和代码特化的泛型类和方法，同时保留了使泛型首次成功的所有重要的渐进迁移能力。 继续前进 Moving ForwardValhalla 项目有非常远大的目标，其应用即深入又广泛，影响到类文件格式、JVM、Java 语言、库和用户模型。（2014 年，James Gosling 将其描述为“六篇博士论文，交织在一起”） 我们打算将 Valhalla 项目的交付分为三个主要阶段：首先是 Identity-free 的值对象，然后是原始类，迁移现有的基本类型和通用泛型，最后是特化泛型。","link":"/2021/12/the-road-to-valhalla/"},{"title":"Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes","text":"解读 JEP 390 Warnings for Value-Based Classes，基于值的类（value-based）的相关警告。 以直译为主，部分内容会意译，一些地方会增加自己的解读。一些概念解释见 深入理解 Valhalla (0): 序言。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects 摘要 Summary将包装类（java.lang.Integer、java.lang.Double 等）设计为为基于值的类，并在构造函数的 @Deprecated 中加入 forRemoval（在 JDK 9 中已经被标记为 @Deprecated）。在任何基于值的类的实例上进行同步（synchronized）时，会发出警告。 可以看下最新的源代码，增加了 forRemovalhttps://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/Integer.java 12345678910111213141516/** * Constructs a newly allocated {@code Integer} object that * represents the specified {@code int} value. * * @param value the value to be represented by the * {@code Integer} object. * * @deprecated * It is rarely appropriate to use this constructor. The static factory * {@link #valueOf(int)} is generally a better choice, as it is * likely to yield significantly better space and time performance. */@Deprecated(since=&quot;9&quot;, forRemoval = true)public Integer(int value) { this.value = value;} 动机 MotivationValhalla 项目希望通过引入原始类（primitive class）来对 Java 编程模型进行重大改进。原始类的实例是 Identity-free 的，能够进行内联和扁平化的表示。这样的实例可以在内存不同位置之间自由复制，也可以仅仅用字段的值进行编码（这里编码可能指内存中的布局）。 原始类的设计和实现已经足够成熟了。我们可以相信在未来的版本中，一些 Java 平台的类将会迁移成原始类。 设计和实现已经足够成熟了，相关的 JEP 都已经进入候选，可以参考后续文章。 迁移的候选者在 API 规范中被非正式的指定为基于值的，这意味着 不可变的 对象的 Identity 对自身的行为来说不重要（就是之前说的 Identity-free） 不提供生成独立 Identity 实例的机制，例如公开的构造函数（每次调用返回的对象都是一个新的 Identity） 非正式的指不改变任何特性，但会设计为符合相关约定，方便后续迁移。 包装类（java.lang.Integer、java.lang.Double 等）也打算成为原始类，这些类都满足上述的要求，除了具有公开的构造函数（在 JDK 9 中已经被标记为 @Deprecated），通过一些修改，包装类依旧可以被当作是基于值的。 基于上述原因，后续包装类的构造函数都会被移除。基于值的类是一个抽象概念，原始类是一个具体的实现，后续不加严格区分可以认为说的是同一个事情。 一般来说，使用者如果按照建议使用，迁移成原始类之后是不会有什么影响的。在后续版本的的 JDK 中运行时，需要注意 相等（equals）的实例也是相同的（==），如果代码中依赖 != 就有可能产生不正确的结果。 使用 new Integer、new Double 等创建实例的时候会产生 LinkageErrors，需要改成使用 valueOf 工厂方法。 尝试在这些类的实例上进行同步将产生异常。 这些改变对一些人来说可能不方便，但解决方法也很简单，如果需要 Identity 可以使用不同的类型（通常可以自定义的类，使用 Object 或者 AtomicReference 也是可以的）。但带来的好处也是非常明显的，更好的性能、更可靠的相等语义、可以统一基本类型和类。对于上述 3 个问题： 已经通过工厂方法的唯一性，避免了上述问题。但没有一种实用的手段，可以监测程序忽略了这种规范。不过预计这种情况会非常少。 在构造函数上增加 forRemoval，当使用上述构造方法时编译器会给出更多的警告。现有的 Java 项目有很大一部分（可能占其中的 1%-10%）调用了上述构造方法，但它们更多都只会运行在 Java 9 之前的版本上。大部分流行的开源项目，都已经根据警告信息进行了修改。增加 forRemoval 之后，更多的项目也会进行相应的修改。在后文依赖部分（Dependencies）中介绍了其他的功能，会更好的帮助迁移。 在编译和运行时的时候增加相关的警告，通知程序员同步（synchronized）操作在未来的版本中将不起作用。 描述 Descriptionjava.lang 中的包装类（Byte、Short、Integer、Long、Float、Double、Boolean 和 Character）已被指定为基于值的。为了防止基于值的实例被错误的使用： 包装类的构造函数，已经被标记为废弃，并且增加了 forRemoval。javac 在编译时默认都会提示警告信息。jdeprscan 工具也可以识别二进制文件中使用已废弃 API 的情况。 javac 新增了同步（synchronized）警告类型，在基于值的类或者所有子类都是基于值的类的实例上使用同步时会给出警告。默认是开启的，可以通过 -Xlint:synchronization 手动选择。 HotSpot 实现了一个运行时检测手段，可以检测在基于值的实例上使用 monitorenter 指令。命令行选项 -XX:DiagnoseSyncOnValueBasedClasses=1 会将操作视为致命错误。命令行选项 -XX:DiagnoseSyncOnValueBasedClasses=2 将通过控制台和 JDK Flight Recorder 事件打开日志记录。 编译时同步警告依赖于静态类型，而运行时警告可以处理非基于值的类和接口类型如 Object，例如： 1234Double d = 20.0;synchronized (d) { ... } // javac warning &amp; HotSpot warningObject o = d;synchronized (o) { ... } // HotSpot warning 在同步代码之外执行 monitorexit 指令，或者 wait、notify 和 notifyAll 本身就会抛出 IllegalMonitorStateException，因此这些操作不需要再进行警告。 标识基于值的类 Identifying Value-Based Classes在 JDK 中，@jdk.internal.ValueBased 注解用于向 javac 和 HotSpot 表明类是基于值的，或者表明抽象类或接口需要基于值的子类。Java API 和 JDK 中下列类型被标记为 @ValueBased 包装类 java.lang.Runtime.Version java.util 中的 optional 类：Optional、OptionalInt、 OptionalLong 和 OptionalDouble java.time 中的 API：Instant、 LocalDate、 LocalTime、 LocalDateTime、 ZonedDateTime、 ZoneId、 OffsetTime、 OffsetDateTime、 ZoneOffset、 Duration、 Period、 Year、 YearMonth、MonthDay、MinguoDate、 HijrahDate、 JapaneseDate 和 ThaiBuddhistDate java.lang.ProcessHandle 接口和实现类 java.util 中的集合工厂方法的实现类：List.of、 List.copyOf、 Set.of、 Set.copyOf、 Map.of、 Map.copyOf、 Map.ofEntries 和 Map.entry 在抽象类或者接口中使用该注解，意味着所有子类也使用了该注解。部分在 java.lang.constant 和 jdk.incubator.foreign 中的类和接口一开始要求是基于值的，但并不符合最新的规范（例如继承了字段），所以不能迁移成原始类。这种情况下这些类不再是基于值的。 影响范围 Scope of ChangesJava SE：优化了包装类、现有的基于值的类、相关的接口和工厂方法的规范，修改了 Java 相关的 API。对于 Java 语言规范和 Java 虚拟机规范，没有任何修改。 JDK：为 javac 和 HotSpot 增加了新的警告和日志记录的功能，一些类增加了 @jdk.internal.ValueBased 注解。 其他选择 Alternatives我们可以放弃将这些类迁移为原始类的努力。但当我们完成迁移时，开发人员将享受到显着的好处，并且对依赖问题行为的开发人员的影响相对较小。 可以用运行时警告补充编译时弃用警告，这留作另未来一个 JEP 的工作（见下文）。 可能还有其他类可以迁移为原始类，包括一些 API 类和由 java.lang.invoke.LambdaMetafactory 等功能生成的类。该 JEP 将自身限制为包装类和已指定为基于值的类。同样，可以在未来的工作中引入额外的警告。 依赖 Dependencies基于值的类迁移为原始类，在增加这些警告之后依然需要充分的准备时间。最重要的是，在该 JEP 完成后的一段时间内，无法将包装类迁移为原始类。 包装类迁移为原始类的另一个前提，是有足够的工具来识别和解决废弃构造函数的使用。将在单独的 JEP 中两个后续功能： 新增 HotSpot 运行时警告，检测已弃用 API 的使用（包括包装类构造函数），作为 javac 和 jdeprscan 的补充。 新增工具，支持运行无法重新编译的二进制文件（其中使用了废弃的构造函数）。例如可以重写字节码以使用 valueOf 方法。（这里应该还包含 JNI 二进制文件）","link":"/2021/10/jep-390/"},{"title":"Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects","text":"解读 JEP 402: Unify the Basic Primitives with Objects (Preview)，统一基本类型和对象。 以直译为主，部分内容会意译，一些地方会增加自己的解读。一些概念解释见 深入理解 Valhalla (0): 序言。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects 摘要 Summary通过将基本值设计为原始类（见 JEP 401）的实例，统一基本类型（int、double 等）和对象，继续用包装类的声明作为原始类的声明。作为改动的结果，Java 中所有的值都是对象了。该提案将会是一项预览特性。 目标 Goals 将 8 个包装类（java.lang.Integer、java.lang.Double 等）迁移为引用优先（Reference-favoring）的原始类。 在 Java 语言中，将基本值视为迁移后的包装类的实例。同时基本类型关键字（int、double 等）将作为对应原始值类型的别名，新的类型支持方法调用、原始引用转换、数组协变。 在 Java 虚拟机中，将基本数组类型视为对应原始对象的数组类型。 在核心反射 API 中，修改 8 个表示基本类型的 Class 对象（int.class、double.class 等）的行为，以便符合它们的类型定义。 这将是一项非常重大的改动，Java 真正变成了一切皆对象，以下代码都将变得合法： 123451.equals(1); // 支持方法调用int.ref one = 1; // 原始引用转换Object[] array = new int[]{1, 2, 3}; // 数组协变// int == Integer.val 等价// int.ref == Integer 等价 非目标 Non-Goals 原始对象和原始类的功能在 JEP 401中介绍，而该 JEP 只考虑如何在 8 个基本类型上应用这些特性。 该 JEP 不涉及原始值类型（int、double 等）和 Java 泛型的交互。单独的 JEP 将满足原始值类型作为类型参数的需求，并最终优化这些参数化的性能。 该 JEP 不会提出任何新的数字基本类型，也没有为 Java 的一元和二元操作符提出任何新功能。· 上述第三点，目前在 Java 中不支持无符号数字，也不支持 128 位整数，但可以预期，未来可以基于原始对象的方式来支持。 动机 MotivationJava 是面向对象的语言，但基本值（布尔、整数和浮点数）都不是对象。在创建语言时，这是一个明智的设计选择，因为每个对象都需要额外的内存开销和间接寻址。但也意味着基本值不支持对象的一些有用的特性，例如实例方法、子类型和后来的泛型。 作为一种解决方案，原来的标准库提供了包装类，每个类都存储了一个基本值，并作为对象呈现。Java 5 引入了隐式的装箱/拆箱，可以根据程序要求把基本类型的值转换成包装类的实例，反之亦然。 但包装类这样的解决方案是不完美的，它并没有完全屏蔽转换的影响（例如同一个值装箱两次，得到的对象可能并不 ==）。更重要的是，在许多应用程序中，将基本值包装在对象中有明显的运行时成本，开发人员必须权衡这些成本和更强大的表达能力。 JEP 401 中介绍了原始对象（Primitive Objects）的特性，将 Identity-free 的值设计为原始对象，能够消除了大部分的额外开销。作为结果，现在可以将基本值在所有的上下文中都当作第一等的对象。最后，我们可以宣称所有的值都是对象。 每个原始对象需要一个原始类，那么 int 的值应该是属于哪个类？大部分现有的代码，都会假设基本值作为对象，应该属于包装类。由于不再需要对基本值进行包装，最小的改动是将包装类改造为原始类，例如 int 值作为 java.lang.Integer 的实例，boolean 值作为 java.lang.Boolean 的实例等。 通过将基本类型修改为原始类，我们可以给它们增加实例方法，并且集成到子类型图中（class subtyping graph）。未来的 JEP 将追求原始值类型和 Java 泛型的交互。 描述 Description以下描述是预览中的特性，需要在编译和运行时增加 --enable-preview 参数。 基本原始类 Basic Primitive Classes8 个基本原始类如下 java.lang.Boolean java.lang.Character java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double 编译器和引导类加载器会通过特殊的方式定位类文件，如果开启了预览特性，会定位到修改之后的类。 修改之后的原始类，它们是引用优先（Reference-favoring）的，意味着 Integer、Double 等类型名继续指它们的引用类型（原始引用类型）。 这些类的公开构造函数，在 JDK 16 中已经被 JEP 390 标记为计划移除（forRemoval）。涉及到 Identity 和原始类构造函数编译方式不同，可能会产生微妙的二进制兼容性问题。为了避免该问题，修改后的类的构造函数是私有的。 Java 语言模型 Java Language Model8 个基本类型关键字（boolean、char、byte、short、int、long、float 和 double）将作为基本原始类和对应原始值类型的别名。.ref 语法被用来表示对应的引用类型。 因为它们是别名，因此每个原始类、原始值类型、原始引用类型都有两种方法表示，见如下表格： 原始类 Primitive Class 值类型 Value Type 引用类型 Reference Type boolean / Boolean boolean / Boolean.val boolean.ref / Boolean char / Character char / Character.val char.ref / Character byte / Byte byte / Byte.val byte.ref / Byte short / Short short / Short.val short.ref / Short int / Integer int / Integer.val int.ref / Integer long / Long long / Long.val long.ref / Long float / Float float / Float.val float.ref / Float double / Double double / Double.val double.ref / Double 代码风格上的问题，我们建议使用小写字母、基于关键字的方式。 原始类声明的限制在基本原始类上会有特例：基本原始类可以递归声明自身原始值类型的字段（例如 int 类可以包含 int 类型的字段）。 Java 支持基本类型之间的转换（例如 int 转 double），这些行为不会发生变化。为清晰期间，我们现在称之为扩展数字转换（Widening Numeric Conversions）和收缩数字转换（Narrowing Numeric Conversions）。引用类型（例如 int.ref 和 double.ref）之间是没有类似的转换的。 装箱/拆箱将会被原始类的原始引用转换（Primitive Reference Conversions）和原始值转换（Primitive Value Conversions）替代。支持的类型是一样的，但运行时的行为会更加高效。 Java 支持一系列的一元和二元操作符来操作基本值（例如 23 * 12、!true），这些操作的规则和行为不会变化。 因为基本值是对象，它们类定义里面也可以定义实例方法。23.compareTo(42) 这样的代码现在是合法的。（TODO：这是否会导致任何语法分析的问题？equals 和 compareTo 这样的行为是否有意义？） 和其他原始值类型一样，基本原始值类型的数组是协变的：int[] 可以视为 int.ref[]、Number[] 等。 编译期和运行时 Compilation and Run Time在 JVM 中，基本类型和原始类类型是不同的：类型 D 表示 64 位浮点数，占用栈上两个 slot，支持一套专有的操作码 (dload、dstore、dadd、dcmpg 等)。类型 Qjava/lang/Double; 表示 Double 的原始对象，占用栈上一个 slot，支持对象的操作码 (aload、astore、invokevirtual 等)。 Java 编译器有义务根据需求适配两种类型，通过调用方法例如 Double.valueOf 和 Double.doubleValue。编译后的字节码跟装箱/拆箱生成的字节码类似，但是运行时开销会大幅减少。 为了一致性，基本原始值类型出现在字段类型和方法签名的时候，永远编译成 JVM 中的基本类型（D 而不是 Qjava/lang/Double;），除了基本原始类本身的定义（例如 Double.valueOf 返回类型 QDouble;）。 编译器的适配，对于基本数组类型来说是不够的。例如通过 newarray 创建的类型为 [D 的数组，可以传递给期望参数为 [Ljava/lang/Double; 的方法。同时通过 anewarray 创建的类型为 [Qjava/lang/Double; 的数组，可以转换为 [D。为了支持上述行为，JVM 将 [D 和 [Qjava/lang/Double; 视为兼容的类型。他们的值同时支持两套操作码（daload 和 aaload、dastore 和 aastore），无论数组是如何创建的。（TODO：getClass().getComponentType() 将如何返回） 核心反射 Core Reflection每一个基本原始类型，开发人员通常会遇到两个 Class 对象。以 Double 类为例，有： double.class（或等价的 Double.val.class）对应 JVM 的描述符类型 D。isPrimitive() 方法返回 true。当开启预览特性的时候，为了跟 Java 语言模型对齐，大多数其他行为类似于 java.lang.Double（例如 isPrimitiveClass、getMethods、getSuperclass 等）。 Double.class（或等价的 double.ref.class）对应 JVM 的描述符类型 Ljava/lang/Double;。isPrimitive() 返回 false。跟表示原始引用类型的标准 Class 对象的行为是类似的。 基本原始对象 getClass() 方法返回第二种 Class 对象（例如 Double.class、Integer.class 等）。对所有的原始对象来说，通过值类型（(23.0).getClass()）或者引用类型（((Double)23.0).getClass()）返回的都是一样的。这跟传统的装箱行为是兼容的。 (23.0).getClass() == Double.class 还存在第三个 Class 对象，对应 JVM 的描述符类型 Qjava/lang/Double;，但在实践中几乎不会使用，因为 Java 编译器几乎不会用该类型描述符名称。也没有类名表示这些对象。isPrimitive() 返回 false。跟表示原始值类型的标准 Class 对象的行为是类似的。 也就是说原始类 Person.class 的描述符是 QPoint;，Person.ref.class 的描述符是 LPoint;，按照相同的逻辑来说 double.class 的描述符是 Qjava/lang/Double;，double.ref.class 的描述符是 Ljava/lang/Double;。但 Java 编译器在遇到 double.class 和 Double.val.class 时为了兼容都会编译成 D，算是一种特殊的处理。 其他选择 Alternatives语言可以保持不变（原始对象是一个有用的特性，但无需将基本值视为对象）。但是消灭基本类型和对象之间的隔阂会非常有用，特别是当 Java 的泛型支持原始对象时。 新类可以作为基本原始类（例如 java.lang.int）引入，而将包装类作为遗留 API。 但是关于装箱行为的假设在某些代码中根深蒂固，而一组新的类会破坏这些程序。 JVM 可以遵循 Java 语言将其基本类型（I、D 等）与其原始类类型（Qjava/lang/Integer;、Qjava/lang/Double; 等）完全统一。但这将是一个代价高昂的改变，最终收益甚微。 例如，必须有一种方法来协调两个 slot 的 D 类型和一个 slot 的 Qjava/lang/Double; 类型，可能需要对类文件格式进行破坏性的版本更改。 风险和假设 Risks and Assumptions删除包装类的构造函数，破坏了遗留 Java 程序的二进制兼容性。还有与迁移到原始类型相关的行为变化。JEP 390 以及一些预期的后续工作减轻了这些负担。但一些调用构造函数或者依赖装箱对象 Identity 的程序会发生错误。 由于新的基本原始类型将作为类类型，反射行为的变化可能导致某些程序出现问题。存在表示 Qjava/lang/Double; 类型的不同对象，很容易被忽略并可能让一些开发人员感到惊讶。 依赖 DependenciesJEP 401 原始对象是必备的条件。考虑到该功能，JEP 390 已经对原始类的候选者们可能产生的不兼容改动，向 javac 和 HotSpot 增加了警告。一些后续工作将在其他的 JEP 中进行。我们期望修改 Java 中的泛型模型，使类型参数更加通用（可以被所有的类实例化，包括引用和值）。这会在单独的 JEP 中进行。","link":"/2021/11/jep-402/"},{"title":"Valhalla (6): 解读 JEP 401 Primitive Objects","text":"解读 JEP 401 Primitive Objects (Preview) ，原始对象。 以直译为主，部分内容会意译，一些地方会增加自己的解读。一些概念解释见 深入理解 Valhalla (0): 序言。 系列文章（未完待续） Valhalla (0): 序言 Valhalla (1): 背景 How We Got the Generics We Have Valhalla (2): 现状 The Road to Valhalla Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes Valhalla (6): 解读 JEP 401 Primitive Objects Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects 摘要 Summary增强 Java 对象模型，允许声明原始类（Primitive Class），原始类的实例称为原始对象（Primitive Object）。这样的对象没有 Identity，可以直接存储和传递，无需对象头和间接寻址。该提案将会是一项预览特性。 目标 Goals该 JEP 会对 Java 语言和虚拟机进行重大的改动，包括： 允许声明原始类 原始类是 Identity-free 的（见概念解释） 原始类的实例称为原始对象 明确原始对象在比较、同步和其他依赖 Identity 的操作时的行为（Identity-related Behavior） 提供无缝的转换机制，允许同时对原始值类型（Primitive Value Type）和原始引用类型（Primitive Reference Type）操作 原始值类型不需要间接寻址就可以存储和传递（类似于 int） 原始引用类型（在处理原始对象时）允许多态（polymorphism）和空引用（null references）（类似于 Integer） 提供无缝的转换机制（类似于自动装箱/拆箱） Codes like a class, works like an int 非目标 Non-Goals该 JEP 只关注原始类和原始类型的声明，不包含其他 Java 语言的改进，但有一些特性会并行开发： JEP 402 统一基本类型和对象 基本类型（int、boolean 等）的值将会被视为原始对象 包装类（Integer、Boolean 等）将会被视为原始类 基本类型的值是包装类的实例（例如 true instanceof Boolean） 一个独立的 JEP 将修改 Java 的泛型机制，允许原始值类型作为类型参数 除了上述 JEP，后续一个非常重要的改进是 JVM 需要根据不同原始值类型的内存布局（layouts）生成特化（specialize）的泛型类和字节码。 后续还可能增强现有的 API 以便更好的使用原始对象的特性，或者引入构建在原始对象之上的语言特性和 API。 动机 MotivationJava 中包含两种类型的值，基本类型（例如数字和布尔值）和引用类型。 基本类型提供更高的性能，可以直接（没有对象头和指针）存储在变量、栈和 CPU 寄存器中。因此访问内存不需要额外的间接寻址，基本类型数组也会紧密且连续地存储在内存中。基本类型也不需要 GC，相关操作都直接在 CPU 内部完成。 引用类型提供更好的抽象，包括字段、方法、访问控制、实例验证、命名类型和子类型多态。同时也是有 Identity 的，支持字段修改、加锁等操作。 在某些领域，开发人员需要基本类型提供的高性能，但代价是必须放弃面向对象中一些有意义的抽象。这可能会导致一些 bug，例如错误的解释无类型的数字，或者错误的处理异构数据的数组（火星气候探测者号的失败极大程度地说明了此类 bug 的潜在成本）。 理想情况下，我们希望 JVM 在运行面向对象的代码时，也能够类似基本类型的性能。不幸的是，尽管很多对象并不需要，但对象的 Identity 是这类性能优化的主要阻碍。在不考虑 Identity 的情况下，JVM 就可以按照基本类型一样处理这些对象（直接存储在变量上和直接在 CPU 内操作）。 具体不需要 Identity 并且可以提升性能的例子： 没有作为基本类型的数字，例如无符号数字、128 位整数和半精度浮点数。 点（Points）、复数、颜色、向量和其他多维数字（矩阵）。 带有单位的数字，例如大小、变化率、温度、货币等。 日期和时间的抽象，包括大量 java.time 包中的类。 元组（Tuples）、记录（record）、Map 中的 entries、数据库行和多返回值。 不可变的 cursors、子数组、中间流（intermediate streams）和其他数据结构视图的抽象。 同样我们可以期待，随着更多对原始对象的操作的实践，新的编程范式和 API 设计也会不断发展。 描述 Description以下描述是预览中的特性，需要在编译和运行时增加 --enable-preview 参数 原始对象和原始类 Primitive Objects and Classes原始对象是一种没有 Identity 的类的实例。也就是说，原始对象没有固定的内存地址或者其他属性，能够在所有字段值相同的情况下区分不同的实例。原始对象字段值是不能修改的，也不能进行同步操作（synchronized）。在原始对象执行 == 操作是比较所有字段的值。实例为原始对象的类被称为原始类。 Identity 对象是有 identity 的类的实例或者数组，有传统 Java 中对象的行为，Identity 对象可以修改非 final 的字段值，并且可以关联同步监视器（执行 synchronized）。在 Identity 对象执行 == 操作是比较它们的 Identity（引用）。实例为 Identity 对象的类被称为 Identity 类。 原始类声明 Primitive Class Declarations类可以通过 primitive 上下文关键字声明为原始类，这样的类会隐式声明为 final 的并且不能是 abstract 的。除了原始类和抽象类之外的类就是 Identity 类。例如 123456789101112131415161718192021222324primitive class Point implements Shape { private double x; private double y; public Point(double x, double y) { this.x = x; this.y = y; } public double x() { return x; } public double y() { return y; } public Point translate(double dx, double dy) { return new Point(x+dx, y+dy); } public boolean contains(Point p) { return equals(p); }}interface Shape { boolean contains(Point p);} 原始类声明受到如下的限制（要区分实例字段/静态字段）： 所有的实例字段都被隐式声明为 final 的，只能在构造函数、初始值、初始化代码块中被赋值一次 所有的实例字段都不能是直接或间接依赖当前类的原始值类型（定义见后文）。换句话说，除了引用类型的字段，类的布局必须是扁平的（flat）、固定大小、没有循环依赖的 简单来说，就是在编译的时候，需要能够计算出对象的内存布局 不能直接或间接实现 IdentityObject 接口（见下文），这意味着父类（们）只能是 Object 或者无状态的抽象类 构造函数不能调用 super 的构造函数。实例的创建不能执行任何父类的初始化代码。 所有的实例方法都不能声明 synchronized （可能）不能实现 Cloneable 接口或者声明 clone() 方法 （可能）不能声明 finalize() 方法 （可能）在所有字段都初始化之前是不能使用 this 的（除了通过 this 设置变量） 其他大多数的声明，原始类和 Identity 类的声明方式是一样的。可以实现多个接口、支持类型参数、内部类、重载构造函数、静态成员和所有的访问控制修饰符。 原始对象使用 Working with Primitive Objects原始对象创建方式就是普通的实例创建表达式。 1Point p1 = new Point(1.0, -0.5); 原始类实例字段和方法访问方式也是一样的。 1Point p2 = p1.translate(p1.y(), 0.0); 原始类可以访问父类或接口中的方法，也可以覆盖它们。实例可以赋值给父类或接口类型。 123System.out.println(p2.toString());Shape s = p2;assert !s.contains(p1); 上面几个操作没什么区别 == 操作将比较两个原始对象的字段值，而不是对象的 Identity。基本类型字段会按位比较，其他的字段会递归通过 == 比较。 12assert new Point(1.0, -0.5) == p1;assert p1.translate(0.0, 0.0) == p1; equals、hashCode 和 toString，包括 System.identityHashCode 在相等的行为定义上是一致的。 12345Point p3 = p1.translate(0.0, 0.0);assert p1.equals(p3);assert p1.hashCode() == p3.hashCode();assert System.identityHashCode(p1) == System.identityHashCode(p3);assert p1.toString().equals(p3.toString()); 在原始对象上进行同步 synchronized 会抛异常。 123Object obj = p1;try { synchronized (obj) { assert false; } }catch (RuntimeException e) { /* expected exception */ } 两个接口 The PrimitiveObject and IdentityObject Interfaces新增了两个必要的接口 java.lang.PrimitiveObject java.lang.IdentityObject 所有的原始类都隐式实现了 PrimitiveObject 接口，所有的 Identity 类都隐式实现了 IdentityObject 接口，包括之前 Java 生态中所有的类，数组仍然是 IdentityObject 的子类型。 这些接口通过如下三种方式帮助区分 Identity 对象和原始对象 instanceof IdentityObject / instanceof PrimitiveObject 可以判断一个对象是否有 Identity，使用 Class 的反射方法也是一样的 IdentityObject / PrimitiveObject 类型的变量可以分别保存有/没有 Identity 的对象 extends IdentityObject / extends PrimitiveObject 的类型变量上界可以要求类型变量分别有/没有 Identity 接口可以显式的继承 IdentityObject 或者 PrimitiveObject 以便要求所有的实现类有/没有 Identity，如果一个类最终显式、隐式或者通过继承，同时实现了两个接口，那么就会发生错误。默认情况下，一个接口是不继承任何一个的上述接口的，可以同时被两种具体的类实现。 类似的，抽象类也可以显式实现 IdentityObject 或者 PrimitiveObject ，但如果声明了字段、初始值、初始化代码块、非空构造函数或同步方法（synchronized），就相当于隐式实现了 IdentityObject 接口（可能会有警告信息）。否则一个抽象类不实现任何一个尚书接口，可以同时被两种具体的类继承。 java.lang.Object 不实现任何一个接口，相当于（可能会被显式指定）是一个抽象类，如上所述，具体的子类可以实现任何一个接口。在调用 new Object() 将会被重新解释为初始化一个 Identity 的 Object 的子类型（名字待定）。 如果最终采用这个方案，那么意味着 java.lang.Object 变成一个抽象类，但同时可以调用 new Object()，而且 new Object().getClass() != Object.class（可能）。意味着会内置一个类 class NameTBD implements IdentityObject {}new Object() 会被重新解释为 new NameTBD()因为需要兼容，这个应该会发生在运行时。 原始值和引用 Primitive Values and References原始对象可以作为原始值（Primitive Values）存储在变量中、进行直接访问、无需对象头和指针，这些值的类型称为原始值类型（Primitive Value Type）。 原始对象也可以像引用类型一样存储和操作，这些引用的类型称为原始引用类型（Primitive Reference Type）。 因此每一个原始类关联两个类型，原始值类型和原始引用类型。原始类的实例可以直接或者间接通过引用处理，这取决于使用的类型。 原始值类型 Primitive Value Types原始类的类名表示这个类的原始值类型（可以声明 reference-favoring 类，这样类名表示引用类型，见下文讨论）。跟传统的类型不同，原始值类型不是对象的引用，而是对象本身。因此有两个重要的结果 原始值类型的变量可以直接存储对象的字段值，不需要对象头或者指针 原始值类型的变量不能为 null Codes like a class, works like an int 原始值类型是单态（monomorphic）的，所有该类型的值都是同一个类的实例，并且有相同的布局。 如果 Point 是原始类，那么Point point = ...;Points points = [...];不管两个变量怎么赋值，因为是单态的，所以一定有point.getClass() == points[0].getClass() == Point.class不知道通过反射构造 Object 对象会怎么样 原始类的创建表达式（new）的类型是原始值类型，类中的 this 表达式的类型也是原始值类型。如上所示，原始值类型允许访问字段和方法，也支持通过 == 和 !== 操作来比较两个同类型的值。原始值类型的表达式是不能用在同步（synchronized）语句中的。 原始类型（int、boolean、double 等）被认识一种不同的类型，不受该 JEP 的影响。 原始值类型的默认值 Default Values of Primitive Value Types每个原始值类型都有一个默认值，用于初始化字段和数组的元素。引用类型的字段默认值是 null，其他类型字段的默认值是 0 或者 false 或者默认值。默认值是该类的默认实例（default 实例），所有字段值都是其类型的默认值。Point.default 表达式用来指代原始类 Point 的默认实例。 123assert new Point(0.0, 0.0) == Point.default;Point[] ps = new Point[100];assert ps[33] == Point.default; 注意默认实例的创建，不需要调用任何构造函数、执行初始化赋值和初始化代码块。能访问该类，就可以访问默认实例（除了 Enforcing 实例验证，见下文）。原始类也不能自行定义默认实例，修改其字段的默认值。 引用类型 Reference Type之前引用类型的变量保存对象的引用或者为 null，但现在引用的对象可以是 Identity 对象或者原始对象。 原始引用类型用 类名.ref 来表示，变量可以保存该类对象的引用或者为 null。原始引用类型是所有该类父类型的子类型。 123Point pi; // stores a Point object 原始值类型Point.ref pr; // stores a reference to a Point 原始引用类型Shape s; // stores a reference to a Shape, which may be a Point 引用类型，可能是 Point 在使用原始对象的时候，一般不需要显式指定原始引用类型（例如 Point.ref），但这是对象模型非常重要的部分，Java 的开发者应该需要理解。 一个类的原始引用类型，和原始值类型拥有相同的成员，支持应用类型的常规操作。特别的，在运行时 == 和 Object 中的方法，在处理原始对象操作时是相同的，不管是当作值还是引用。 在任何 PrimitiveObject 实例上执行同步（synchronized）操作会发生错误，包括原始引用类型。 跟装箱类似，原始值类型可以隐式转换引用类型，称为原始引用转换（primitive reference conversions）。但原始引用转换是非常轻量级的，不会产生新的 Identity。 123Point p1 = new Point(3.0, -2.1);Point.ref[] prs = new Point.ref[1];prs[0] = p1; // convert Point to Point.ref 隐式转换 跟拆箱类似，原始引用类型可以隐式转换为值类型，称为原始值转换（primitive value conversion）。如果引用为 null，转换会抛出 NullPointerException。 123Point p2 = prs[0]; // Convert Point.ref to Pointprs[0] = null;p2 = prs[0]; // NullPointerException 异常 在方法调用的时候，为了跟方法的参数类型定义匹配，也会发生隐式类型转换。 123p1.toString(); // Convert Point to ObjectShape s = p1;s.contains(p1); // Convert Shape to Point 一般情况下，在使用原始类型的时候，都可以简单的使用值类型。不过在下列场景中，引用类型会很有帮助 当需要子类型多态时（polymorphism），例如原始对象需要作为接口的实例 当需要空值 null 时，例如某些算法需要一个哨兵 当需要通过间接寻址的引用，打破原始类字段之间的循环引用（根据上文描述的声明的限制） 当使用引用有更高的性能时（见下文讨论） 目前 Java 的泛型只适用于引用类型，后续的 JEP 会改进泛型机制，可以同时适用于值类型。 重载解析和参数类型解析 Overload Resolution and Type Argument Inference原始引用/值转换只能发生在宽松的、非严格的调用上下文，这跟装箱/拆箱的模式是一致的：不需要转换就可以适用的方法优先级高于需要转换的。 1234567void m(Point p, int i) { ... }void m(Point.ref pr, Integer i) { ... }void test(Point.ref pr, Integer i) { m(pr, i); // prefers the second declaration 使用第二个方法 m(pr, 0); // ambiguous 两个方法都需要转换，因此是有歧义的} 参数类型推断在处理原始引用/值转换时，还是跟装箱/拆箱一致的。在需要推断的时候，原始值会被推断为引用类型。 12var list = List.of(new Point(1.0, 5.0));// infers List&lt;Point.ref&gt; 默认推断为引用类型 （在未来的 JEP 中，将会被允许推断为值类型） 数组子类型 Array Subtyping原始类实例的数组是协变的，即 Point[] 是 Point.ref[] 的子类型，Point.ref[] 又是 Object[] 的子类型。 目前的基本类型数组（int[]、double[] 等）是不变的（不支持协） 一个静态类型为 Object[] 运行时元素类型为 Point 的数组中，储存一个引用时，会执行数组存储检查（检查引用是指向 Point 类的实例），并且执行原始值转换（把引用转换为原始值）。同样的，从静态类型为 Object[] 数组中读取元素，如果值为原始值，会发生原始引用转换。 123456789Object replace(Object[] objs, int i, Object val) { Object result = objs[i]; // may perform reference conversion 可能发生引用转换 objs[i] = val; // may perform value conversion 可能发生值转换 return result;}Point[] ps = new Point[]{ new Point(3.0, -2.1) };replace(ps, 0, new Point(-2.1, 3.0));replace(ps, 0, null); // NullPointerException from value conversion 有点类似于 Integer[] 保存/读取 int 时的行为，用现有 Java 来说明的话 12345678910Integer replace(Integer[] objs, int i, Integer val) { Integer result = objs[i]; // 可能发生引用转换 objs[i] = val; // 可能发生值转换 return result;}int[] ps = new int[]{ 2, 3 };// 注意目前版本不允许，基本类型数组是不变的，int[] 不是 Integer[] 的子类型replace(ps, 0, Integer.valueOf(2));replace(ps, 0, null); // NullPointerException from value conversion 引用优先的原始类和迁移 Reference-Favoring Primitive Classes and Migration有一些类是可以被声明为原始类的（不可变，也不需要 Identity），但使用者更希望跟之前一样使用引用类型，尤其是可以为空 null。主要的场景是希望声明一个类是 Identity 类，但可以兼容的重构为原始类。（标准库中有很多类已经被设计为基于值的类，期望可以迁移成原始类。）在这种情况下，一个类可以被声明为原始类，但使用特殊的名称（语法可能会变化） 123primitive class Time.val { ...} 这种语法的类型 Time.val 是原始值类型，同时 Time 表示对应的原始引用类型。 12Time[] trefs = new Time[]{ new Time(...) };Time.val t = trefs[0]; // primitive value conversion 总结一下类名和类型的关系 原始类 类型 类名 值类型 引用类型 标准 Foo Foo Foo.ref 引用优先 reference-favoring Bar Bar.val Bar （有一个问题，是否允许在标准的值类型名后面冗余 .val ，或者 reference-favoring 的引用类型名后面冗余 .ref）除了在根据类名解析类型之外，reference-favoring 原始类跟标准的原始类是完全一样的。 可以理解为，为了兼容之前的代码，引入了这个新的概念，例如之后 Integer 还是引用类型，可以为空。否则迁移会变的非常麻烦。 为了能够把已有的 Identity 类迁移为原始类，开发者需要注意，即使已经重构成 reference-favoring，使用者仍然会能感知到一些差异 调用了非公开构造方法的代码会导致链接错误（linkage error），需要重新编译（见后文讨论） 以前认为 != 的两个实例，有可能会变成 == 相等的 执行同步（synchronized）会失败 未完待续","link":"/2021/10/jep-401/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"matplotlib","slug":"matplotlib","link":"/tags/matplotlib/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"quine","slug":"quine","link":"/tags/quine/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"classloader","slug":"classloader","link":"/tags/classloader/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"icarus","slug":"hexo/icarus","link":"/categories/hexo/icarus/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"ubuntu","slug":"linux/ubuntu","link":"/categories/linux/ubuntu/"},{"name":"matplotlib","slug":"python/matplotlib","link":"/categories/python/matplotlib/"}]}