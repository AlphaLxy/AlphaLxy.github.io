<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Valhalla (6): 解读 JEP 401 Primitive Objects - Alpha Lxy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Alpha Lxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Alpha Lxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="解读 JEP 401 Primitive Objects (Preview) ，原始对象。"><meta property="og:type" content="blog"><meta property="og:title" content="Valhalla (6): 解读 JEP 401 Primitive Objects"><meta property="og:url" content="https://www.alphalxy.com/2021/10/jep-401/"><meta property="og:site_name" content="Alpha Lxy"><meta property="og:description" content="解读 JEP 401 Primitive Objects (Preview) ，原始对象。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.alphalxy.com/img/og_image.png"><meta property="article:published_time" content="2021-10-28T14:11:32.000Z"><meta property="article:modified_time" content="2021-12-25T16:28:46.286Z"><meta property="article:author" content="Xinyu Liu"><meta property="article:tag" content="java"><meta property="article:tag" content="jvm"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.alphalxy.com/2021/10/jep-401/"},"headline":"Valhalla (6): 解读 JEP 401 Primitive Objects","image":["https://www.alphalxy.com/img/og_image.png"],"datePublished":"2021-10-28T14:11:32.000Z","dateModified":"2021-12-25T16:28:46.286Z","author":{"@type":"Person","name":"Xinyu Liu"},"publisher":{"@type":"Organization","name":"Alpha Lxy","logo":{"@type":"ImageObject","url":"https://www.alphalxy.com/img/logo.svg"}},"description":"解读 JEP 401 Primitive Objects (Preview) ，原始对象。"}</script><link rel="canonical" href="https://www.alphalxy.com/2021/10/jep-401/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Alpha Lxy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="AlphaLxy GitHub" href="https://www.github.com/AlphaLxy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Valhalla (6): 解读 JEP 401 Primitive Objects</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-10-28T14:11:32.000Z" title="2021-10-28T14:11:32.000Z">2021-10-28</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-12-25T16:28:46.286Z" title="2021-12-25T16:28:46.286Z">2021-12-26</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/java/">java</a></span><span class="level-item"><i class="far fa-clock"></i> 37 minutes read (About 5501 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>解读 <a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/401">JEP 401 Primitive Objects (Preview) </a>，原始对象。</p>
<a id="more"></a>
<blockquote>
<p>以直译为主，部分内容会意译，一些地方会增加自己的解读。一些概念解释见 <a href="https://www.alphalxy.com/2021/10/valhalla/">深入理解 Valhalla (0): 序言</a>。</p>
</blockquote>
<h2 id="系列文章（未完待续）"><a href="#系列文章（未完待续）" class="headerlink" title="系列文章（未完待续）"></a>系列文章（未完待续）</h2><div class="menu-list is-size-6">
<a target="_blank" href="https://www.alphalxy.com/2021/10/valhalla/"><i class="fas fa-bookmark mr-2"></i>Valhalla (0): 序言</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/"><i class="fas fa-bookmark mr-2"></i>Valhalla (1): 背景 How We Got the Generics We Have</a>
<a target="_blank" href="https://www.alphalxy.com/2021/12/the-road-to-valhalla/"><i class="fas fa-bookmark mr-2"></i>Valhalla (2): 现状 The Road to Valhalla</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/jep-390/"><i class="fas fa-bookmark mr-2"></i>Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/jep-401/"><i class="fas fa-bookmark mr-2"></i>Valhalla (6): 解读 JEP 401 Primitive Objects</a>
<a target="_blank" href="https://www.alphalxy.com/2021/11/jep-402/"><i class="fas fa-bookmark mr-2"></i>Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects</a>
</div>


<h2 id="摘要-Summary"><a href="#摘要-Summary" class="headerlink" title="摘要 Summary"></a>摘要 Summary</h2><p>增强 Java 对象模型，允许声明原始类（Primitive Class），原始类的实例称为原始对象（Primitive Object）。这样的对象没有 Identity，可以直接存储和传递，无需对象头和间接寻址。该提案将会是一项预览特性。</p>
<h2 id="目标-Goals"><a href="#目标-Goals" class="headerlink" title="目标 Goals"></a>目标 Goals</h2><p>该 JEP 会对 Java 语言和虚拟机进行重大的改动，包括：</p>
<ul>
<li>允许声明原始类<ul>
<li>原始类是 Identity-free 的（见概念解释）</li>
<li>原始类的实例称为原始对象</li>
<li>明确原始对象在比较、同步和其他依赖 Identity 的操作时的行为（Identity-related Behavior）</li>
</ul>
</li>
<li>提供无缝的转换机制，允许同时对原始值类型（Primitive Value Type）和原始引用类型（Primitive Reference Type）操作<ul>
<li>原始值类型不需要间接寻址就可以存储和传递（类似于 <code>int</code>）</li>
<li>原始引用类型（在处理原始对象时）允许多态（polymorphism）和空引用（null references）（类似于 <code>Integer</code>）</li>
<li>提供无缝的转换机制（类似于自动装箱/拆箱）</li>
</ul>
</li>
</ul>
<blockquote>
<p>Codes like a class, works like an int</p>
</blockquote>
<h2 id="非目标-Non-Goals"><a href="#非目标-Non-Goals" class="headerlink" title="非目标 Non-Goals"></a>非目标 Non-Goals</h2><p>该 JEP 只关注原始类和原始类型的声明，不包含其他 Java 语言的改进，但有一些特性会并行开发：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/402">JEP 402 统一基本类型和对象</a><ul>
<li>基本类型（<code>int</code>、<code>boolean</code> 等）的值将会被视为原始对象</li>
<li>包装类（<code>Integer</code>、<code>Boolean</code> 等）将会被视为原始类</li>
<li>基本类型的值是包装类的实例（例如 <code>true instanceof Boolean</code>）</li>
</ul>
</li>
<li>一个独立的 JEP 将修改 Java 的泛型机制，允许原始值类型作为类型参数</li>
</ul>
<p>除了上述 JEP，后续一个非常重要的改进是 JVM 需要根据不同原始值类型的内存布局（layouts）生成特化（specialize）的泛型类和字节码。</p>
<p>后续还可能增强现有的 API 以便更好的使用原始对象的特性，或者引入构建在原始对象之上的语言特性和 API。</p>
<h2 id="动机-Motivation"><a href="#动机-Motivation" class="headerlink" title="动机 Motivation"></a>动机 Motivation</h2><p>Java 中包含两种类型的值，基本类型（例如数字和布尔值）和引用类型。</p>
<p>基本类型提供更高的性能，可以直接（没有对象头和指针）存储在变量、栈和 CPU 寄存器中。因此访问内存不需要额外的间接寻址，基本类型数组也会紧密且连续地存储在内存中。基本类型也不需要 GC，相关操作都直接在 CPU 内部完成。</p>
<p>引用类型提供更好的抽象，包括字段、方法、访问控制、实例验证、命名类型和子类型多态。同时也是有 Identity 的，支持字段修改、加锁等操作。</p>
<p>在某些领域，开发人员需要基本类型提供的高性能，但代价是必须放弃面向对象中一些有意义的抽象。这可能会导致一些 bug，例如错误的解释无类型的数字，或者错误的处理异构数据的数组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">火星气候探测者号</a>的失败极大程度地说明了此类 bug 的潜在成本）。</p>
<p>理想情况下，我们希望 JVM 在运行面向对象的代码时，也能够类似基本类型的性能。不幸的是，尽管很多对象并不需要，但对象的 Identity 是这类性能优化的主要阻碍。在不考虑 Identity 的情况下，JVM 就可以按照基本类型一样处理这些对象（直接存储在变量上和直接在 CPU 内操作）。</p>
<p>具体不需要 Identity 并且可以提升性能的例子：</p>
<ul>
<li>没有作为基本类型的数字，例如无符号数字、128 位整数和半精度浮点数。</li>
<li>点（Points）、复数、颜色、向量和其他多维数字（矩阵）。</li>
<li>带有单位的数字，例如大小、变化率、温度、货币等。</li>
<li>日期和时间的抽象，包括大量 java.time 包中的类。</li>
<li>元组（Tuples）、<a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/395">记录（record）</a>、Map 中的 entries、数据库行和多返回值。</li>
<li>不可变的 cursors、子数组、中间流（intermediate streams）和其他数据结构视图的抽象。</li>
</ul>
<p>同样我们可以期待，随着更多对原始对象的操作的实践，新的编程范式和 API 设计也会不断发展。</p>
<h2 id="描述-Description"><a href="#描述-Description" class="headerlink" title="描述 Description"></a>描述 Description</h2><p>以下描述是预览中的特性，需要在编译和运行时增加 <code>--enable-preview</code> 参数</p>
<h3 id="原始对象和原始类-Primitive-Objects-and-Classes"><a href="#原始对象和原始类-Primitive-Objects-and-Classes" class="headerlink" title="原始对象和原始类 Primitive Objects and Classes"></a>原始对象和原始类 Primitive Objects and Classes</h3><p>原始对象是一种没有 Identity 的类的实例。也就是说，原始对象没有固定的内存地址或者其他属性，能够在所有字段值相同的情况下区分不同的实例。原始对象字段值是不能修改的，也不能进行同步操作（<code>synchronized</code>）。在原始对象执行 == 操作是比较所有字段的值。实例为原始对象的类被称为原始类。</p>
<p>Identity 对象是有 identity 的类的实例或者数组，有传统 Java 中对象的行为，Identity 对象可以修改非 final 的字段值，并且可以关联同步监视器（执行 <code>synchronized</code>）。在 Identity 对象执行 == 操作是比较它们的 Identity（引用）。实例为 Identity 对象的类被称为 Identity 类。</p>
<h4 id="原始类声明-Primitive-Class-Declarations"><a href="#原始类声明-Primitive-Class-Declarations" class="headerlink" title="原始类声明 Primitive Class Declarations"></a>原始类声明 Primitive Class Declarations</h4><p>类可以通过 primitive 上下文关键字声明为原始类，这样的类会隐式声明为 <code>final</code> 的并且不能是 <code>abstract</code> 的。<br>除了原始类和抽象类之外的类就是 Identity 类。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">primitive <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">translate</span><span class="params">(<span class="keyword">double</span> dx, <span class="keyword">double</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x+dx, y+dy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equals(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Point p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类声明受到如下的限制（要区分实例字段/静态字段）：</p>
<ul>
<li>所有的实例字段都被隐式声明为 <code>final</code> 的，只能在构造函数、初始值、初始化代码块中被赋值一次</li>
<li>所有的实例字段都不能是直接或间接依赖当前类的原始值类型（定义见后文）。换句话说，除了引用类型的字段，类的布局必须是扁平的（flat）、固定大小、没有循环依赖的<ul>
<li>简单来说，就是在编译的时候，需要能够计算出对象的内存布局</li>
</ul>
</li>
<li>不能直接或间接实现 <code>IdentityObject</code> 接口（见下文），这意味着父类（们）只能是 <code>Object</code> 或者无状态的抽象类</li>
<li>构造函数不能调用 <code>super</code> 的构造函数。实例的创建不能执行任何父类的初始化代码。</li>
<li>所有的实例方法都不能声明 <code>synchronized</code></li>
<li>（可能）不能实现 <code>Cloneable</code> 接口或者声明 <code>clone()</code> 方法</li>
<li>（可能）不能声明 <code>finalize()</code> 方法</li>
<li>（可能）在所有字段都初始化之前是不能使用 <code>this</code> 的（除了通过 <code>this</code> 设置变量）</li>
</ul>
<p>其他大多数的声明，原始类和 Identity 类的声明方式是一样的。可以实现多个接口、支持类型参数、内部类、重载构造函数、静态成员和所有的访问控制修饰符。</p>
<h4 id="原始对象使用-Working-with-Primitive-Objects"><a href="#原始对象使用-Working-with-Primitive-Objects" class="headerlink" title="原始对象使用 Working with Primitive Objects"></a>原始对象使用 Working with Primitive Objects</h4><p>原始对象创建方式就是普通的实例创建表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1.0</span>, -<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>

<p>原始类实例字段和方法访问方式也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p2 = p1.translate(p1.y(), <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>

<p>原始类可以访问父类或接口中的方法，也可以覆盖它们。实例可以赋值给父类或接口类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p2.toString());</span><br><span class="line">Shape s = p2;</span><br><span class="line"><span class="keyword">assert</span> !s.contains(p1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面几个操作没什么区别</p>
</blockquote>
<p>== 操作将比较两个原始对象的字段值，而不是对象的 Identity。基本类型字段会按位比较，其他的字段会递归通过 == 比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">assert</span> new <span class="title">Point</span><span class="params">(<span class="number">1.0</span>, -<span class="number">0.5</span>)</span> </span>== p1;</span><br><span class="line"><span class="keyword">assert</span> p1.translate(<span class="number">0.0</span>, <span class="number">0.0</span>) == p1;</span><br></pre></td></tr></table></figure>

<p><code>equals</code>、<code>hashCode</code> 和 <code>toString</code>，包括 <code>System.identityHashCode</code> 在相等的行为定义上是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p3 = p1.translate(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">assert</span> p1.equals(p3);</span><br><span class="line"><span class="keyword">assert</span> p1.hashCode() == p3.hashCode();</span><br><span class="line"><span class="keyword">assert</span> System.identityHashCode(p1) == System.identityHashCode(p3);</span><br><span class="line"><span class="keyword">assert</span> p1.toString().equals(p3.toString());</span><br></pre></td></tr></table></figure>

<p>在原始对象上进行同步 <code>synchronized</code> 会抛异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = p1;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="keyword">synchronized</span> (obj) &#123; <span class="keyword">assert</span> <span class="keyword">false</span>; &#125; &#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">/* expected exception */</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个接口-The-PrimitiveObject-and-IdentityObject-Interfaces"><a href="#两个接口-The-PrimitiveObject-and-IdentityObject-Interfaces" class="headerlink" title="两个接口 The PrimitiveObject and IdentityObject Interfaces"></a>两个接口 The PrimitiveObject and IdentityObject Interfaces</h4><p>新增了两个必要的接口</p>
<ul>
<li><code>java.lang.PrimitiveObject</code></li>
<li><code>java.lang.IdentityObject</code></li>
</ul>
<p>所有的原始类都隐式实现了 <code>PrimitiveObject</code> 接口，所有的 Identity 类都隐式实现了 <code>IdentityObject</code> 接口，包括之前 Java 生态中所有的类，数组仍然是 <code>IdentityObject</code> 的子类型。</p>
<p>这些接口通过如下三种方式帮助区分 Identity 对象和原始对象</p>
<ul>
<li><code>instanceof IdentityObject</code> / <code>instanceof PrimitiveObject</code> 可以判断一个对象是否有 Identity，使用 Class 的反射方法也是一样的</li>
<li><code>IdentityObject</code> / <code>PrimitiveObject</code> 类型的变量可以分别保存有/没有 Identity 的对象</li>
<li><code>extends IdentityObject</code> / <code>extends PrimitiveObject</code> 的类型变量上界可以要求类型变量分别有/没有 Identity</li>
</ul>
<p>接口可以显式的继承 <code>IdentityObject</code> 或者 <code>PrimitiveObject</code> 以便要求所有的实现类有/没有 Identity，如果一个类最终显式、隐式或者通过继承，同时实现了两个接口，那么就会发生错误。默认情况下，一个接口是不继承任何一个的上述接口的，可以同时被两种具体的类实现。</p>
<p>类似的，抽象类也可以显式实现 <code>IdentityObject</code> 或者 <code>PrimitiveObject</code> ，但如果声明了字段、初始值、初始化代码块、非空构造函数或同步方法（<code>synchronized</code>），就相当于隐式实现了 <code>IdentityObject</code> 接口（可能会有警告信息）。否则一个抽象类不实现任何一个尚书接口，可以同时被两种具体的类继承。</p>
<p><code>java.lang.Object</code> 不实现任何一个接口，相当于（可能会被显式指定）是一个抽象类，如上所述，具体的子类可以实现任何一个接口。在调用 <code>new Object()</code> 将会被重新解释为初始化一个 Identity 的 <code>Object</code> 的子类型（名字待定）。</p>
<blockquote>
<p>如果最终采用这个方案，那么意味着 <code>java.lang.Object</code> 变成一个抽象类，但同时可以调用 <code>new Object()</code>，<br>而且 <code>new Object().getClass() != Object.class</code>（可能）。<br>意味着会内置一个类 <code>class NameTBD implements IdentityObject &#123;&#125;</code><br><code>new Object()</code> 会被重新解释为 <code>new NameTBD()</code><br>因为需要兼容，这个应该会发生在运行时。</p>
</blockquote>
<h3 id="原始值和引用-Primitive-Values-and-References"><a href="#原始值和引用-Primitive-Values-and-References" class="headerlink" title="原始值和引用 Primitive Values and References"></a>原始值和引用 Primitive Values and References</h3><p>原始对象可以作为原始值（Primitive Values）存储在变量中、进行直接访问、无需对象头和指针，这些值的类型称为原始值类型（Primitive Value Type）。</p>
<p>原始对象也可以像引用类型一样存储和操作，这些引用的类型称为原始引用类型（Primitive Reference Type）。</p>
<p>因此每一个原始类关联两个类型，原始值类型和原始引用类型。原始类的实例可以直接或者间接通过引用处理，这取决于使用的类型。</p>
<h4 id="原始值类型-Primitive-Value-Types"><a href="#原始值类型-Primitive-Value-Types" class="headerlink" title="原始值类型 Primitive Value Types"></a>原始值类型 Primitive Value Types</h4><p>原始类的类名表示这个类的原始值类型（可以声明 reference-favoring 类，这样类名表示引用类型，见下文讨论）。跟传统的类型不同，原始值类型不是对象的引用，而是对象本身。因此有两个重要的结果</p>
<ul>
<li>原始值类型的变量可以直接存储对象的字段值，不需要对象头或者指针</li>
<li>原始值类型的变量不能为 <code>null</code></li>
</ul>
<blockquote>
<p>Codes like a class, works like an int</p>
</blockquote>
<p>原始值类型是单态（monomorphic）的，所有该类型的值都是同一个类的实例，并且有相同的布局。</p>
<blockquote>
<p>如果 <code>Point</code> 是原始类，那么<br><code>Point point = ...;</code><br><code>Points points = [...];</code><br>不管两个变量怎么赋值，因为是单态的，所以一定有<br><code>point.getClass() == points[0].getClass() == Point.class</code><br>不知道通过反射构造 <code>Object</code> 对象会怎么样</p>
</blockquote>
<p>原始类的创建表达式（<code>new</code>）的类型是原始值类型，类中的 <code>this</code> 表达式的类型也是原始值类型。<br>如上所示，原始值类型允许访问字段和方法，也支持通过 == 和 !== 操作来比较两个同类型的值。<br>原始值类型的表达式是不能用在同步（<code>synchronized</code>）语句中的。</p>
<p>原始类型（<code>int</code>、<code>boolean</code>、<code>double</code> 等）被认识一种不同的类型，不受该 JEP 的影响。</p>
<h4 id="原始值类型的默认值-Default-Values-of-Primitive-Value-Types"><a href="#原始值类型的默认值-Default-Values-of-Primitive-Value-Types" class="headerlink" title="原始值类型的默认值 Default Values of Primitive Value Types"></a>原始值类型的默认值 Default Values of Primitive Value Types</h4><p>每个原始值类型都有一个默认值，用于初始化字段和数组的元素。引用类型的字段默认值是 <code>null</code>，其他类型字段的默认值是 0 或者 <code>false</code> 或者默认值。默认值是该类的默认实例（default 实例），所有字段值都是其类型的默认值。<code>Point.default</code> 表达式用来指代原始类 <code>Point</code> 的默认实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">assert</span> new <span class="title">Point</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span> </span>== Point.<span class="keyword">default</span>;</span><br><span class="line">Point[] ps = <span class="keyword">new</span> Point[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">assert</span> ps[<span class="number">33</span>] == Point.<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>注意默认实例的创建，不需要调用任何构造函数、执行初始化赋值和初始化代码块。能访问该类，就可以访问默认实例（除了 Enforcing 实例验证，见下文）。原始类也不能自行定义默认实例，修改其字段的默认值。</p>
<h4 id="引用类型-Reference-Type"><a href="#引用类型-Reference-Type" class="headerlink" title="引用类型 Reference Type"></a>引用类型 Reference Type</h4><p>之前引用类型的变量保存对象的引用或者为 <code>null</code>，但现在引用的对象可以是 Identity 对象或者原始对象。</p>
<p>原始引用类型用 类名.ref 来表示，变量可以保存该类对象的引用或者为 <code>null</code>。原始引用类型是所有该类父类型的子类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point pi; <span class="comment">// stores a Point object 原始值类型</span></span><br><span class="line">Point.ref pr; <span class="comment">// stores a reference to a Point 原始引用类型</span></span><br><span class="line">Shape s; <span class="comment">// stores a reference to a Shape, which may be a Point 引用类型，可能是 Point</span></span><br></pre></td></tr></table></figure>

<p>在使用原始对象的时候，一般不需要显式指定原始引用类型（例如 <code>Point.ref</code>），但这是对象模型非常重要的部分，Java 的开发者应该需要理解。</p>
<p>一个类的原始引用类型，和原始值类型拥有相同的成员，支持应用类型的常规操作。特别的，在运行时 == 和 <code>Object</code> 中的方法，在处理原始对象操作时是相同的，不管是当作值还是引用。</p>
<p>在任何 <code>PrimitiveObject</code> 实例上执行同步（<code>synchronized</code>）操作会发生错误，包括原始引用类型。</p>
<p>跟装箱类似，原始值类型可以隐式转换引用类型，称为原始引用转换（primitive reference conversions）。但原始引用转换是非常轻量级的，不会产生新的 Identity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">3.0</span>, -<span class="number">2.1</span>);</span><br><span class="line">Point.ref[] prs = <span class="keyword">new</span> Point.ref[<span class="number">1</span>];</span><br><span class="line">prs[<span class="number">0</span>] = p1; <span class="comment">// convert Point to Point.ref 隐式转换</span></span><br></pre></td></tr></table></figure>

<p>跟拆箱类似，原始引用类型可以隐式转换为值类型，称为原始值转换（primitive value conversion）。如果引用为 <code>null</code>，转换会抛出 <code>NullPointerException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p2 = prs[<span class="number">0</span>]; <span class="comment">// Convert Point.ref to Point</span></span><br><span class="line">prs[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">p2 = prs[<span class="number">0</span>]; <span class="comment">// NullPointerException 异常</span></span><br></pre></td></tr></table></figure>

<p>在方法调用的时候，为了跟方法的参数类型定义匹配，也会发生隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.toString(); <span class="comment">// Convert Point to Object</span></span><br><span class="line">Shape s = p1;</span><br><span class="line">s.contains(p1); <span class="comment">// Convert Shape to Point</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，在使用原始类型的时候，都可以简单的使用值类型。不过在下列场景中，引用类型会很有帮助</p>
<ul>
<li>当需要子类型多态时（polymorphism），例如原始对象需要作为接口的实例</li>
<li>当需要空值 <code>null</code> 时，例如某些算法需要一个哨兵</li>
<li>当需要通过间接寻址的引用，打破原始类字段之间的循环引用（根据上文描述的声明的限制）</li>
<li>当使用引用有更高的性能时（见下文讨论）</li>
</ul>
<p>目前 Java 的泛型只适用于引用类型，后续的 JEP 会改进泛型机制，可以同时适用于值类型。</p>
<h4 id="重载解析和参数类型解析-Overload-Resolution-and-Type-Argument-Inference"><a href="#重载解析和参数类型解析-Overload-Resolution-and-Type-Argument-Inference" class="headerlink" title="重载解析和参数类型解析 Overload Resolution and Type Argument Inference"></a>重载解析和参数类型解析 Overload Resolution and Type Argument Inference</h4><p>原始引用/值转换只能发生在宽松的、非严格的调用上下文，这跟装箱/拆箱的模式是一致的：不需要转换就可以适用的方法优先级高于需要转换的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(Point p, <span class="keyword">int</span> i)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m</span><span class="params">(Point.ref pr, Integer i)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Point.ref pr, Integer i)</span> </span>&#123;</span><br><span class="line">    m(pr, i); <span class="comment">// prefers the second declaration 使用第二个方法</span></span><br><span class="line">    m(pr, <span class="number">0</span>); <span class="comment">// ambiguous 两个方法都需要转换，因此是有歧义的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数类型推断在处理原始引用/值转换时，还是跟装箱/拆箱一致的。在需要推断的时候，原始值会被推断为引用类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="keyword">new</span> Point(<span class="number">1.0</span>, <span class="number">5.0</span>));</span><br><span class="line"><span class="comment">// infers List&lt;Point.ref&gt; 默认推断为引用类型</span></span><br></pre></td></tr></table></figure>

<p>（在未来的 JEP 中，将会被允许推断为值类型）</p>
<h4 id="数组子类型-Array-Subtyping"><a href="#数组子类型-Array-Subtyping" class="headerlink" title="数组子类型 Array Subtyping"></a>数组子类型 Array Subtyping</h4><p>原始类实例的数组是协变的，即 <code>Point[]</code> 是 <code>Point.ref[]</code> 的子类型，<code>Point.ref[]</code> 又是 <code>Object[]</code> 的子类型。</p>
<blockquote>
<p>目前的基本类型数组（<code>int[]</code>、<code>double[]</code> 等）是不变的（不支持协）</p>
</blockquote>
<p>一个静态类型为 <code>Object[]</code> 运行时元素类型为 <code>Point</code> 的数组中，储存一个引用时，会执行数组存储检查（检查引用是指向 <code>Point</code> 类的实例），并且执行原始值转换（把引用转换为原始值）。<br>同样的，从静态类型为 <code>Object[]</code> 数组中读取元素，如果值为原始值，会发生原始引用转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">replace</span><span class="params">(Object[] objs, <span class="keyword">int</span> i, Object val)</span> </span>&#123;</span><br><span class="line">    Object result = objs[i]; <span class="comment">// may perform reference conversion 可能发生引用转换</span></span><br><span class="line">    objs[i] = val; <span class="comment">// may perform value conversion 可能发生值转换</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point[] ps = <span class="keyword">new</span> Point[]&#123; <span class="keyword">new</span> Point(<span class="number">3.0</span>, -<span class="number">2.1</span>) &#125;;</span><br><span class="line">replace(ps, <span class="number">0</span>, <span class="keyword">new</span> Point(-<span class="number">2.1</span>, <span class="number">3.0</span>));</span><br><span class="line">replace(ps, <span class="number">0</span>, <span class="keyword">null</span>); <span class="comment">// NullPointerException from value conversion</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有点类似于 Integer[] 保存/读取 int 时的行为，用现有 Java 来说明的话</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Integer <span class="title">replace</span><span class="params">(Integer[] objs, <span class="keyword">int</span> i, Integer val)</span> </span>&#123;</span><br><span class="line">    Integer result = objs[i]; <span class="comment">// 可能发生引用转换</span></span><br><span class="line">    objs[i] = val; <span class="comment">// 可能发生值转换</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ps = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// 注意目前版本不允许，基本类型数组是不变的，int[] 不是 Integer[] 的子类型</span></span><br><span class="line">replace(ps, <span class="number">0</span>, Integer.valueOf(<span class="number">2</span>));</span><br><span class="line">replace(ps, <span class="number">0</span>, <span class="keyword">null</span>); <span class="comment">// NullPointerException from value conversion</span></span><br></pre></td></tr></table></figure>

<h4 id="引用优先的原始类和迁移-Reference-Favoring-Primitive-Classes-and-Migration"><a href="#引用优先的原始类和迁移-Reference-Favoring-Primitive-Classes-and-Migration" class="headerlink" title="引用优先的原始类和迁移 Reference-Favoring Primitive Classes and Migration"></a>引用优先的原始类和迁移 Reference-Favoring Primitive Classes and Migration</h4><p>有一些类是可以被声明为原始类的（不可变，也不需要 Identity），但使用者更希望跟之前一样使用引用类型，尤其是可以为空 <code>null</code>。主要的场景是希望声明一个类是 Identity 类，但可以兼容的重构为原始类。（标准库中有很多类已经被设计为基于值的类，期望可以迁移成原始类。）<br>在这种情况下，一个类可以被声明为原始类，但使用特殊的名称（语法可能会变化）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">primitive <span class="class"><span class="keyword">class</span> <span class="title">Time</span>.<span class="title">val</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种语法的类型 Time.val 是原始值类型，同时 Time 表示对应的原始引用类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time[] trefs = <span class="keyword">new</span> Time[]&#123; <span class="keyword">new</span> Time(...) &#125;;</span><br><span class="line">Time.val t = trefs[<span class="number">0</span>]; <span class="comment">// primitive value conversion</span></span><br></pre></td></tr></table></figure>

<p>总结一下类名和类型的关系</p>
<table>
<thead>
<tr>
<th>原始类 类型</th>
<th>类名</th>
<th>值类型</th>
<th>引用类型</th>
</tr>
</thead>
<tbody><tr>
<td>标准</td>
<td>Foo</td>
<td>Foo</td>
<td>Foo.ref</td>
</tr>
<tr>
<td>引用优先 reference-favoring</td>
<td>Bar</td>
<td>Bar.val</td>
<td>Bar</td>
</tr>
</tbody></table>
<p>（有一个问题，是否允许在标准的值类型名后面冗余 .val ，或者 reference-favoring 的引用类型名后面冗余 .ref）<br>除了在根据类名解析类型之外，reference-favoring 原始类跟标准的原始类是完全一样的。</p>
<blockquote>
<p>可以理解为，为了兼容之前的代码，引入了这个新的概念，例如之后 Integer 还是引用类型，可以为空。<br>否则迁移会变的非常麻烦。</p>
</blockquote>
<p>为了能够把已有的 Identity 类迁移为原始类，开发者需要注意，即使已经重构成 reference-favoring，使用者仍然会能感知到一些差异</p>
<ul>
<li>调用了非公开构造方法的代码会导致链接错误（linkage error），需要重新编译（见后文讨论）</li>
<li>以前认为 != 的两个实例，有可能会变成 == 相等的</li>
<li>执行同步（<code>synchronized</code>）会失败</li>
</ul>
<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3></div><div class="article-licensing box"><div class="licensing-title"><p>Valhalla (6): 解读 JEP 401 Primitive Objects</p><p><a href="https://www.alphalxy.com/2021/10/jep-401/">https://www.alphalxy.com/2021/10/jep-401/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Xinyu Liu</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-28</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-12-26</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/java/">java, </a><a class="link-muted" rel="tag" href="/tags/jvm/">jvm </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/jep-402/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/jep-390/"><span class="level-item">Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.2.5/dist/disqusjs.css"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script src="https://cdn.jsdelivr.net/npm/disqusjs@1.2.5/dist/disqus.js"></script><script>new DisqusJS({
            shortname: 'alphalxy-blog',
            apikey: ["5vNlbaVFbUWJEfg45a4W2eS1pGk6YDf3BoRmbUt5oCteUtJalJxdik6EgZWDGICC","M6U0tycmlOwkeadjgjGrrUYJZzR7LFakiur7ad78eImTGkJjqU1lFgHXAPzZHNb8","lVltbGH4pPUYFwdOi0JDh1hmwMRtuUF05Yyc1MyBUoJRBQhn4wQoG90VB0j3N1NJ","uQbbc193Lwj7pyDJRszhRZRs6Kl7PPfpVjAgfN46WNmUoFaqTpiZ7dxkPYL13NNZ","mu8gCIMF7kJw1sxvCsrndjV8HfRzswjS38kjPkpimTIfZ3DmSvA3UK3r7WWVLdNJ"],
            siteName: "Alpha Lxy",
            identifier: "2021/10/jep-401/",
            url: "https://www.alphalxy.com/2021/10/jep-401/",
            title: "Valhalla (6): 解读 JEP 401 Primitive Objects",
            api: "https://disqus.skk.moe/disqus/",
            
            
            
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.svg" alt="Xinyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xinyu Liu</p><p class="is-size-6 is-block">liuxinyu0922@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">Posts</p><div><p class="title">13</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">Categories</p><div><p class="title">7</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">Tags</p><div><p class="title">10</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.github.com/AlphaLxy" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#系列文章（未完待续）"><span class="level-left"><span class="level-item">1</span><span class="level-item">系列文章（未完待续）</span></span></a></li><li><a class="level is-mobile" href="#摘要-Summary"><span class="level-left"><span class="level-item">2</span><span class="level-item">摘要 Summary</span></span></a></li><li><a class="level is-mobile" href="#目标-Goals"><span class="level-left"><span class="level-item">3</span><span class="level-item">目标 Goals</span></span></a></li><li><a class="level is-mobile" href="#非目标-Non-Goals"><span class="level-left"><span class="level-item">4</span><span class="level-item">非目标 Non-Goals</span></span></a></li><li><a class="level is-mobile" href="#动机-Motivation"><span class="level-left"><span class="level-item">5</span><span class="level-item">动机 Motivation</span></span></a></li><li><a class="level is-mobile" href="#描述-Description"><span class="level-left"><span class="level-item">6</span><span class="level-item">描述 Description</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原始对象和原始类-Primitive-Objects-and-Classes"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">原始对象和原始类 Primitive Objects and Classes</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原始类声明-Primitive-Class-Declarations"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">原始类声明 Primitive Class Declarations</span></span></a></li><li><a class="level is-mobile" href="#原始对象使用-Working-with-Primitive-Objects"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">原始对象使用 Working with Primitive Objects</span></span></a></li><li><a class="level is-mobile" href="#两个接口-The-PrimitiveObject-and-IdentityObject-Interfaces"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">两个接口 The PrimitiveObject and IdentityObject Interfaces</span></span></a></li></ul></li><li><a class="level is-mobile" href="#原始值和引用-Primitive-Values-and-References"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">原始值和引用 Primitive Values and References</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原始值类型-Primitive-Value-Types"><span class="level-left"><span class="level-item">6.2.1</span><span class="level-item">原始值类型 Primitive Value Types</span></span></a></li><li><a class="level is-mobile" href="#原始值类型的默认值-Default-Values-of-Primitive-Value-Types"><span class="level-left"><span class="level-item">6.2.2</span><span class="level-item">原始值类型的默认值 Default Values of Primitive Value Types</span></span></a></li><li><a class="level is-mobile" href="#引用类型-Reference-Type"><span class="level-left"><span class="level-item">6.2.3</span><span class="level-item">引用类型 Reference Type</span></span></a></li><li><a class="level is-mobile" href="#重载解析和参数类型解析-Overload-Resolution-and-Type-Argument-Inference"><span class="level-left"><span class="level-item">6.2.4</span><span class="level-item">重载解析和参数类型解析 Overload Resolution and Type Argument Inference</span></span></a></li><li><a class="level is-mobile" href="#数组子类型-Array-Subtyping"><span class="level-left"><span class="level-item">6.2.5</span><span class="level-item">数组子类型 Array Subtyping</span></span></a></li><li><a class="level is-mobile" href="#引用优先的原始类和迁移-Reference-Favoring-Primitive-Classes-and-Migration"><span class="level-left"><span class="level-item">6.2.6</span><span class="level-item">引用优先的原始类和迁移 Reference-Favoring Primitive Classes and Migration</span></span></a></li></ul></li><li><a class="level is-mobile" href="#未完待续"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">未完待续</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Alpha Lxy" height="28"></a><p class="is-size-7"><span>&copy; 2021 Xinyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="AlphaLxy GitHub" href="https://www.github.com/AlphaLxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>