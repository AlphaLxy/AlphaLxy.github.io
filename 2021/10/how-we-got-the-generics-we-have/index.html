<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Valhalla (1): 背景 How We Got the Generics We Have - Alpha Lxy</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Alpha Lxy"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Alpha Lxy"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="翻译 https:&amp;#x2F;&amp;#x2F;openjdk.java.net&amp;#x2F;projects&amp;#x2F;valhalla&amp;#x2F;design-notes&amp;#x2F;in-defense-of-erasure。 在我们讨论泛型该如何发展时，我们首先要看看当前泛型是什么样的。这篇文章主要聚焦在泛型是如何发展到现在的，以及为什么会是这个样子，了解这些可以帮助我们基于现有的泛型尝试构建出“更好”的泛型。 特别是，我们强调擦除实际上是 2004 年将泛"><meta property="og:type" content="blog"><meta property="og:title" content="Valhalla (1): 背景 How We Got the Generics We Have"><meta property="og:url" content="https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/"><meta property="og:site_name" content="Alpha Lxy"><meta property="og:description" content="翻译 https:&amp;#x2F;&amp;#x2F;openjdk.java.net&amp;#x2F;projects&amp;#x2F;valhalla&amp;#x2F;design-notes&amp;#x2F;in-defense-of-erasure。 在我们讨论泛型该如何发展时，我们首先要看看当前泛型是什么样的。这篇文章主要聚焦在泛型是如何发展到现在的，以及为什么会是这个样子，了解这些可以帮助我们基于现有的泛型尝试构建出“更好”的泛型。 特别是，我们强调擦除实际上是 2004 年将泛"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.alphalxy.com/img/og_image.png"><meta property="article:published_time" content="2021-10-08T12:42:11.000Z"><meta property="article:modified_time" content="2021-12-25T16:12:29.000Z"><meta property="article:author" content="Xinyu Liu"><meta property="article:tag" content="java"><meta property="article:tag" content="jvm"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.alphalxy.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/"},"headline":"Valhalla (1): 背景 How We Got the Generics We Have","image":["https://www.alphalxy.com/img/og_image.png"],"datePublished":"2021-10-08T12:42:11.000Z","dateModified":"2021-12-25T16:12:29.000Z","author":{"@type":"Person","name":"Xinyu Liu"},"publisher":{"@type":"Organization","name":"Alpha Lxy","logo":{"@type":"ImageObject","url":"https://www.alphalxy.com/img/logo.svg"}},"description":"翻译 https:&#x2F;&#x2F;openjdk.java.net&#x2F;projects&#x2F;valhalla&#x2F;design-notes&#x2F;in-defense-of-erasure。 在我们讨论泛型该如何发展时，我们首先要看看当前泛型是什么样的。这篇文章主要聚焦在泛型是如何发展到现在的，以及为什么会是这个样子，了解这些可以帮助我们基于现有的泛型尝试构建出“更好”的泛型。 特别是，我们强调擦除实际上是 2004 年将泛"}</script><link rel="canonical" href="https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Alpha Lxy" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="AlphaLxy GitHub" href="https://www.github.com/AlphaLxy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Valhalla (1): 背景 How We Got the Generics We Have</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-10-08T12:42:11.000Z" title="2021-10-08T12:42:11.000Z">2021-10-08</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2021-12-25T16:12:29.000Z" title="2021-12-25T16:12:29.000Z">2021-12-26</time></span><span class="level-item"><i class="far fa-folder-open has-text-grey"></i> <a class="link-muted" href="/categories/java/">java</a></span><span class="level-item"><i class="far fa-clock"></i> 41 minutes read (About 6166 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>翻译 <a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/valhalla/design-notes/in-defense-of-erasure">https://openjdk.java.net/projects/valhalla/design-notes/in-defense-of-erasure</a>。</p>
<p>在我们讨论泛型该如何发展时，我们首先要看看当前泛型是什么样的。这篇文章主要聚焦在泛型是如何发展到现在的，以及为什么会是这个样子，了解这些可以帮助我们基于现有的泛型尝试构建出“更好”的泛型。</p>
<p>特别是，我们强调擦除实际上是 2004 年将泛型添加到 Java 时明智且务实的选择，而且很多导致我们选择擦除的因素至今仍在运作。</p>
<span id="more"></span>
<h2 id="系列文章（未完待续）"><a href="#系列文章（未完待续）" class="headerlink" title="系列文章（未完待续）"></a>系列文章（未完待续）</h2><div class="menu-list is-size-6">
<a target="_blank" href="https://www.alphalxy.com/2021/10/valhalla/"><i class="fas fa-bookmark mr-2"></i>Valhalla (0): 序言</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/"><i class="fas fa-bookmark mr-2"></i>Valhalla (1): 背景 How We Got the Generics We Have</a>
<a target="_blank" href="https://www.alphalxy.com/2021/12/the-road-to-valhalla/"><i class="fas fa-bookmark mr-2"></i>Valhalla (2): 现状 The Road to Valhalla</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/jep-390/"><i class="fas fa-bookmark mr-2"></i>Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes</a>
<a target="_blank" href="https://www.alphalxy.com/2021/10/jep-401/"><i class="fas fa-bookmark mr-2"></i>Valhalla (6): 解读 JEP 401 Primitive Objects</a>
<a target="_blank" href="https://www.alphalxy.com/2021/11/jep-402/"><i class="fas fa-bookmark mr-2"></i>Valhalla (7): 解读 JEP 402 Unify the Basic Primitives with Objects</a>
</div>

<h2 id="擦除-Erasure"><a href="#擦除-Erasure" class="headerlink" title="擦除 Erasure"></a>擦除 Erasure</h2><p>向任何开发人员询问 Java 泛型，你可能会得到关于擦除的负面情绪（虽然通常是不知情的）。擦除可能是 Java 中最广泛、最深入被误解的概念了。</p>
<p>擦除不是 Java 特有的，也不是泛型特有的，它是一种无处不在且必要的工具，用于将代码转换为较低级别的代码（例如从 Java 源代码编译为字节码，或将 C 源代码编译为本地代码）。这是因为当我们从高级语言转换到到中间表示再到本地代码再到硬件时，底层提供的类型抽象几乎总是比高层提供更弱更简单，这也是合理的（我们不想将虚拟分派的语义加入到 X86 指令集中，或者在其寄存器中支持 Java 的基本类型）。擦除是一种将更丰富的类型映射到较低级别的简单类型的技术（理想情况下，在更高级别执行完整的类型检查之后），这也是编译器的日常工作。</p>
<p>例如，Java 字节码包含在堆栈和局部变量（<code>iload</code>、<code>istore</code>）之间移动整数值的指令，以及对整数（<code>iadd</code>、<code>imul</code> 等）进行算术运算的指令。单精度浮点数（<code>fload</code>、<code>fstore</code>、<code>fmul</code> 等）、长整数（<code>lload</code>、<code>lstore</code>、<code>lmul</code>）、双精度浮点数（<code>dload</code>、<code>dstore</code>、<code>dmul</code>）和对象引用（<code>aload</code>、<code>astore</code>）都有类似的指令。但其他基本类型（<code>byte</code>、<code>short</code>、<code>char</code> 和 <code>boolean</code>）没有这样的指令，因为这些类型被编译器擦除为整数，并使用整数移动和算术指令。这是字节码指令集设计的权衡，它降低了指令集的复杂性，进而可以提高运行时的效率。Java 语言的许多其他特性（例如检查异常、方法重载、枚举、definite assignment analysis、内部类、通过 lambda 或局部类捕获局部变量等）是“语言错觉”，它们在 Java 编译器中检查，但在转换为类文件时被擦除了。</p>
<p>类似地，在将 C 编译为本机代码时，有符号和无符号整数都被擦除到通用寄存器中（没有单独的有符号寄存器和无符号寄存器），并且 const 变量存储在可变寄存器和可变的内存中。我们根本不觉得这种擦除很奇怪。</p>
<h2 id="同构与异构翻译-Homogeneous-vs-Heterogeneous-Translations"><a href="#同构与异构翻译-Homogeneous-vs-Heterogeneous-Translations" class="headerlink" title="同构与异构翻译 Homogeneous vs. Heterogeneous Translations"></a>同构与异构翻译 Homogeneous vs. Heterogeneous Translations</h2><p>在具有参数多态性的语言中，翻译泛型类型有两种常用的方法：同构和异构翻译。在同构翻译中，泛型类 <code>Foo&lt;T&gt;</code> 被转换为单一的产物，例如 <code>Foo.class</code> （对于泛型方法也是如此）。在异构翻译中，泛型类型或方法的每个实例(<code>Foo&lt;String&gt;</code>、<code>Foo&lt;Integer&gt;</code>) 都被视为一个单独的实体，并生成独立的产物。例如，C++ 使用异构翻译，模板的不同实例是完全不同的类型，具有不同的语义和不同的生成代码。<code>vector&lt;int&gt;</code> 和 <code>vector&lt;float&gt;</code> 是不同的类型。一方面，这对于类型安全（每个实例可以在扩展后单独进行类型检查）和生成代码的质量（因为每个实例可以单独优化）非常有用。另一方面，这意味着更大的代码空间占用（因为 <code>vector&lt;int&gt;</code> 和 <code>vector&lt;float&gt;</code> 有独立的代码），我们不能谈论“某个东西的 vector”（就像 Java 通过通配符所做的那样），因为每个实例都是一个完整的不相关的类型。（作为对可能的占用空间成本的极端演示，Scala 试验了一个 <code>@specialized</code> 注解，当应用于类型变量时，会导致编译器为所有基本类型生成专门的版本。这听起来很酷，但导致生成类的数量随着类型变量的数量爆炸式增长，因此可以从几行代码轻松生成一个 100MB 的 JAR 文件。）</p>
<p>在同构和异构翻译之间的选择，涉及到语言设计者一直在进行的各种权衡。异构翻译提供了更多的类型特异性，但代价是更大的静态和动态开销，以及更少的运行时共享，所有这些都会对性能产生影响。同构翻译更适合抽象相似的参数类型，例如 Java 的通配符或 C# 的 declaration-site variance（C++ 缺少这两者，<code>vector&lt;int&gt;</code> 和 <code>vector&lt;float&gt;</code> 之间没有任何共同点）。有关翻译策略的更多信息，请参阅<a target="_blank" rel="noopener" href="http://pizzacompiler.sourceforge.net/doc/pizza-translation.pdf">这篇有影响力的论文</a>。</p>
<h2 id="在-Java-中擦除泛型-Erased-Generics-in-Java"><a href="#在-Java-中擦除泛型-Erased-Generics-in-Java" class="headerlink" title="在 Java 中擦除泛型 Erased Generics in Java"></a>在 Java 中擦除泛型 Erased Generics in Java</h2><p>Java 使用同构翻译来翻译泛型。泛型在编译时进行类型检查，但是在生成字节码时，像 <code>List&lt;String&gt;</code> 这样的泛型类型会被擦除到 <code>List</code>，而像 <code>&lt;T extends Object&gt;</code> 这样的类型变量会被擦除到它们的边界（在这种情况下就是 <code>Object</code>）。<br>如果我们有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(T t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Box&lt;T&gt; <span class="title function_">copy</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">t</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javac 编译器构建出一个单一的类文件 <code>Box.class</code>，作为 <code>Box</code> 的所有实例化的实现，包括通配符 (<code>Box&lt;?&gt;</code>) 和原始类型 (<code>Box</code>)。字段、方法、父类型的描述都被擦除，类型变量被擦除到它们的边界，泛型类型参数被擦除到它们的原始类型（<code>List&lt;String&gt;</code> 擦除到 <code>List</code>），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Object t)</span> &#123; <span class="built_in">this</span>.t = t; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Box <span class="title function_">copy</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Box</span>(t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">t</span><span class="params">()</span> &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：上面一段描述比较绕，指的是类型参数出现在不同的位置，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&lt;</span><br><span class="line">    F <span class="keyword">extends</span> <span class="title class_">Number</span>,</span><br><span class="line">    M <span class="keyword">extends</span> <span class="title class_">List</span>&lt;F&gt;,</span><br><span class="line">    S <span class="keyword">extends</span> <span class="title class_">Serializable</span>,</span><br><span class="line">    E <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> F field;</span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">private</span> S object;</span><br><span class="line"></span><br><span class="line">    M <span class="title function_">t</span><span class="params">(M m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被擦除为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Number field;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line">    <span class="keyword">private</span> Serializable object;</span><br><span class="line"></span><br><span class="line">    List <span class="title function_">t</span><span class="params">(List m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型签名会被保留在 Signature 属性中，以便编译器在读取类文件时可以看到泛型签名，但 JVM 在链接时仅使用擦除后的描述符。这种转换方案意味着在类文件级别，<code>Box&lt;T&gt;</code> 的布局和 API 都被擦除了。同样的事情也会发生在使用的时候，对 <code>Box&lt;String&gt;</code> 的引用被擦除到 <code>Box</code>，并且会插入到 <code>String</code> 的类型转换。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> box.t();</span><br></pre></td></tr></table></figure>

<p>会被转换成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String)box.t();</span><br></pre></td></tr></table></figure>

<h2 id="有没有替代方案-Why-What-were-the-Alternatives"><a href="#有没有替代方案-Why-What-were-the-Alternatives" class="headerlink" title="有没有替代方案 Why? What were the Alternatives?"></a>有没有替代方案 Why? What were the Alternatives?</h2><p>正是在这一点上，人们很容易生气并宣称这是愚蠢或懒惰的选择，或者说擦除是一种非常 hack 的行为。毕竟，为什么编译器会丢弃完美的类型信息呢？</p>
<p>为了更好地理解这个问题，我们还应该问：我们是否要特化该类型信息，我们希望用它做什么，以及与之相关的成本是多少？我们可以设想几种不同的场景，需要使用特化的类型参数信息：</p>
<ul>
<li><strong>反射：</strong>对于某些人来说，“特化泛型”仅仅意味着可以知道 <code>List</code> 它是什么的列表，无论是使用诸如 <code>instanceof</code> 之类的语言特性或对类型变量进行模式匹配，还是使用反射库来查询类型参数。</li>
<li><strong>特化 API 和布局：</strong>在有基本类型或者内联类的语言中，将 <code>Pair&lt;int, int&gt;</code> 布局扁平化成两个 <code>int</code> 会更好，而不是两个指向包装对象的引用。</li>
<li><strong>运行时类型检查：</strong>当使用者尝试将 <code>Integer</code> 放入 <code>List&lt;String&gt;</code> 中时（例如，通过 <code>List</code> 原始类型引用），会导致内存污染。能够识别这类问题并失败，会比（可能的）后续再通过类型转换检测会更好。</li>
</ul>
<blockquote>
<p>把 <code>Integer</code> 放入 <code>List&lt;String&gt;</code> ，在后续不会读取的情况下，可能是不会出报错的。</p>
</blockquote>
<p>虽然并不相互排斥，但这三种可能（反射、特化和类型检查）有助于实现不同的目标（分别是便利性、性能和安全性），并且具有不同的含义和成本。虽然说“我们想要特化”很容易，但如果深入研究，会发现，对于什么是最重要的、它们的成本和收益是什么，是存在巨大分歧的。</p>
<p>要了解擦除在这里是多么明智和务实的选择，我们还必须了解当时的目标、优先事项和限制以及替代方案。</p>
<h2 id="逐步迁移兼容性-Goal-Gradual-Migration-Compatibility"><a href="#逐步迁移兼容性-Goal-Gradual-Migration-Compatibility" class="headerlink" title="逐步迁移兼容性 Goal: Gradual Migration Compatibility"></a>逐步迁移兼容性 Goal: Gradual Migration Compatibility</h2><p>Java 泛型定了一个雄心勃勃的要求：必须能够以二进制兼容和源代码兼容的方式将现有的非泛型类演化为泛型类。</p>
<p>这意味着现有的调用者和子类，比如 <code>ArrayList</code>，可以继续重新编译而不改变成泛型的 <code>ArrayList&lt;T&gt;</code>，并且现有的类文件将继续链接到泛型的 <code>ArrayList&lt;T&gt;</code> 的方法。满足上述要求，意味着调用者和泛化类的子类可以选择立即、稍后或永远不进行泛化，并且可以独立于其他调用者或子类的维护者的选择。</p>
<p>如果没有这个要求，生成一个类将需要一个“截止日期”，所有调用者和子类就算不修改，但至少必须重新编译。对于像 <code>ArrayList</code> 这样的核心类，这本质上要求重新编译世界上所有的 Java 代码（或永久降级保留在 Java 1.4 上）。因为整个 Java 生态中已经不存在这样的“截止日期”，所以我们需要一个泛型类型系统，允许核心平台类（以及流行的第三方库）被泛化，而不需要调用者知道它们被泛化。（更糟糕的是，它不会是一个确定的时间，因为世界上所有的代码都不可能在同一个时刻被泛型化）</p>
<p>另一种满足此要求的方式是：隔离所有可以被泛化的代码被认为是不可接受的，或者让开发人员在泛型之间进行选择并保留它们已有的代码。通过使泛化成为兼容操作，可以保留已有的代码，而不是废弃掉。</p>
<blockquote>
<p>原文有点绕，感觉上是在说，可以单独设计一套 API（例如 <code>GenericList&lt;T&gt;</code> ），然后之前的 API 继续存在（例如只有 <code>List</code> 而不存在 <code>List&lt;T&gt;</code> ），这样开发人员可以自行选择，之前的代码都可以继续保留。</p>
</blockquote>
<p>对“截止日期”的厌恶来自 Java 设计的一个基本原则：Java 是单独编译和动态链接的。单独编译是指将每个源文件编译成一个或多个类文件，而不是将一组源文件编译成单个产物。动态链接意味着类之间的引用在运行时基于符号信息链接的：如果类 C 在调用了 D 中 <code>void m(int x)</code> 方法，那么在 C 的类文件中我们记录了调用的方法的名称和描述符 <code>(I)V</code>，并在链接时在 D 中查找一个方法使用此名称和描述符，如果找到匹配项，则链接该调用。</p>
<p>这听起来像是非常巨大的工作，但是将编译和动态链接分开是 Java 的最大优势之一：可以针对一个版本的 D 编译 C，并在类路径上使用不同版本的 D 运行（只要不破坏二进制兼容性）。对动态链接的承诺允许我们简单地在类路径上放置一个新的 JAR 以更新到依赖项的新版本，而无需重新编译任何东西。 我们经常这样做，甚至都没有注意到。但是如果出现问题，它确实会被注意到。</p>
<p>在泛型被引入 Java 的时候，世界上已经有非常多的 Java 代码，它们的类文件中充满了对 <code>java.util.ArrayList</code> 等 API 的引用。如果我们不能兼容地泛化这些 API，那么我们将不得不编写新的 API 来替换它们。更糟糕的是，所有旧 API 的调用代码都将陷入一个站不住脚的选择：要么永远停留在 1.4，要么重写它们以同时使用新的 API（不仅包括应用程序代码，还包括应用程序依赖的所有第三方库）。这会影响当时几乎所有存在的 Java 代码。</p>
<p>C# 做出了相反的选择：更新他们的 VM，并使它们现有的库和所有依赖它的用户代码无效（需要升级到泛型）。当时他们可以这样做，因为世界上的 C# 代码相对较少，但 Java 当时没有这个选项。</p>
<p>然而这种选择的一个结果是，一个泛型类将同时拥有泛型和非泛型调用者或子类，这将是一种预期的情况。这对软件开发过程来说是一个福音（兼容），但在这种混合使用下对类型安全有潜在的影响。</p>
<h2 id="内存污染-Heap-Pollution"><a href="#内存污染-Heap-Pollution" class="headerlink" title="内存污染 Heap Pollution"></a>内存污染 Heap Pollution</h2><p>以这种方式擦除，并支持泛型和非泛型调用者之间的相互操作，会产生内存污染的可能性：存储在 <code>Box</code> 中内容的运行时类型，与预期的编译时类型不兼容。 当调用者使用 <code>Box&lt;String&gt;</code> 时，会插入 <code>T</code> 到 <code>String</code> 的类型转换，所以在类型变量（<code>Box</code> 的实现）到具体类型转换的时候，内存污染会被检测出来。在存在堆污染的情况下，类型转换会失败。</p>
<p>内存污染可能来自非泛型代码使用泛型类，或者当我们使用未经检查的强制转换或原始类型，来伪造对错误泛型类型变量的引用时 （当我们使用未经检查的强制转换或原始类型时，编译器会发出警告），例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; bs = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;(<span class="string">&quot;hi!&quot;</span>);   <span class="comment">// safe</span></span><br><span class="line">Box&lt;?&gt; bq = bs;                      <span class="comment">// safe, via subtyping</span></span><br><span class="line">Box&lt;Integer&gt; bi = (Box&lt;Integer&gt;) bq; <span class="comment">// unchecked cast -- warning issued</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> bi.get();                <span class="comment">// ClassCastException in synthetic cast to Integer</span></span><br></pre></td></tr></table></figure>

<p>这段代码的错误是从 <code>Box&lt;?&gt;</code> 到 <code>Box&lt;Integer&gt;</code> 的未经检查的转换：我们必须相信开发人员的说法，即指定的 <code>Box</code> 确实是 <code>Box&lt;Integer&gt;</code>。但是内存污染并没有立即被捕获，只有当我们尝试将 <code>Box</code> 中的字符串用作整数时，才会检测到出现问题。在同构翻译下，如果我们在将 <code>Box</code> 用作 <code>Box&lt;String&gt;</code> 之前将 <code>Box&lt;Integer&gt;</code> 转换成 <code>Box&lt;String&gt;</code>，不会发生任何事情（无论好坏）。但在异构翻译下，<code>Box&lt;String&gt;</code> 和 <code>Box&lt;Integer&gt;</code> 将具有不同的运行时类型，并且此转换将失败。</p>
<p>Java 语言实际上为泛型提供了相当强大的安全保证，只要我们遵循以下规则：如果程序编译时没有未检查或原始类型警告（不考虑反射之类的情况），则编译器插入的强制转换永远不会失败。</p>
<blockquote>
<p>未检查警告：Unchecked cast: ‘…’ to ‘…’ 。<br>原始类型警告：Raw use of parameterized class ‘…’ 。</p>
</blockquote>
<p>换句话说，只有当我们与非泛型代码进行交互或对编译器撒谎时，才会发生内存污染。在发现内存污染时，我们会得到一个明确的异常（<code>ClassCastException</code>），告诉我们预期的类型和实际的类型。</p>
<h2 id="JVM-生态-Context-Ecosystem-of-JVM-Implementations-and-Languages"><a href="#JVM-生态-Context-Ecosystem-of-JVM-Implementations-and-Languages" class="headerlink" title="JVM 生态 Context: Ecosystem of JVM Implementations and Languages"></a>JVM 生态 Context: Ecosystem of JVM Implementations and Languages</h2><p>围绕泛型的设计选择还受到 JVM 实现生态结构和在 JVM 上运行的语言结构的影响。虽然对大多数开发人员来说，“Java”是一个整体的概念，但实际上 Java 语言和 Java 虚拟机 (JVM) 是独立的实体，分别有自己的规范。 Java 编译器为 JVM 生成类文件（其格式和语义在 Java 虚拟机规范中列出），但是 JVM 会很乐意运行任何有效的类文件，而不管它最初来自什么源语言。据统计，有超过 200 种语言使用 JVM 作为编译目标，其中一些与 Java 语言（例如 Scala、Kotlin）有很多共同点，而另一些则是非常不同的语言（例如，JRuby、Jython、Jaskell）。</p>
<p>JVM 作为编译目标如此成功的一个原因（即使是与 Java 完全不同的语言），是它提供了一个相当抽象的计算模型，而受 Java 语言本身的影响有限（独立的规范）。语言和虚拟机之间的抽象层不仅激发了在 JVM 上运行的其他语言的生态，而且对 JVM 独立实现的生态也很有用。虽然今天的市场已经大幅整合，但在将泛型添加到 Java 时，有十多种商业上可行的 JVM 实现。将泛型特化意味着我们不仅需要增强语言以支持泛型，还需要增强 JVM。</p>
<p>虽然当时在技术上可以为 JVM 添加泛型支持，但这不仅是一项需要大量实现者之间协调的重大工程，而且 JVM 上的语言生态也可能有关于特化泛型的意见。例如，如果特化的解释执行包括运行时的类型检查，Scala（及它的 declaration-site variance）是否愿意让 JVM 强制执行 Java 中的（不变的）泛型子类型规则？</p>
<h2 id="擦除是务实的妥协-Erasure-was-the-Pragmatic-Compromise"><a href="#擦除是务实的妥协-Erasure-was-the-Pragmatic-Compromise" class="headerlink" title="擦除是务实的妥协 Erasure was the Pragmatic Compromise"></a>擦除是务实的妥协 Erasure was the Pragmatic Compromise</h2><p>总之，这些限制（技术和生态）作为一股强大的力量推动我们走向同构翻译策略，即在编译时擦除泛型类型信息。 总而言之，推动我们做出这一决定的因素包括：</p>
<ul>
<li><strong>运行时成本。</strong>异构转换需要各种运行时成本：更大的静态和动态占用空间、更大的类加载成本、更大的 JIT 成本和代码缓存压力等。这可能使开发人员不得不在类型安全和性能之间做出选择。</li>
<li><strong>迁移的兼容性。</strong>当时还没有已知的翻译方案允许迁移到特化的泛型，并保持源代码和二进制兼容，从而造成“截止日期”并使开发人员需要对大量现有代码进行改动。</li>
<li><strong>还是运行时成本。</strong>如果将特化解释为在运行时检查类型（就像动态检查 Java 协变数组中的存储一样），这将对运行时产生重大影响，因为 JVM 必须在运行时对每个字段或数组元素存储时执行泛型子类型检查，使用语言的泛型类型系统。当类型像 <code>List&lt;String&gt;</code> 这样的简单类型时，这可能听起来既简单又成本低，但是当遇到像 <code>Map&lt;? extends List&lt;? super Foo&gt;&gt;, ? super Set&lt;? extends Bar&gt;&gt;</code> 这样的类型时会很快变得成本高昂。（事实上，后来的研究对泛型子类型的可判定性产生了怀疑）</li>
<li><strong>JVM 生态。</strong>能够让十几家 JVM 供应商就是否以及如何在运行时特化类型达成一致，是非常不现实的。</li>
<li><strong>交付。</strong>即使有可能让十几个 JVM 供应商就一个实际可行的方案达成一致，也会大大增加复杂性、时间周期和风险，这是非常复杂且冒险的工作。</li>
<li><strong>语言生态。</strong>像 Scala 这样的语言可能不乐意将 Java 的不变泛型融入 JVM 的语义中。就 JVM 中泛型跨语言可接受的语义达成一致，将再次增加复杂性、时间周期和风险，这是非常复杂且冒险的工作。</li>
<li><strong>无论如何，用户都必须处理擦除（因此也必须处理内存污染）。</strong>即使可以在运行时保留类型信息，在类被泛化之前总是会编译出原始的类文件，因此堆中仍然可能存在没有任何附加类型信息的 <code>ArrayList</code>，一样有内存污染的风险。</li>
<li><strong>某些有用的语句是无法表达的。</strong>当现有的泛型代码知道一些编译器不知道的运行时类型时，它偶尔会诉诸未经检查的强制转换，并且在泛型类型系统中没有简单的方法来表达它。许多这样的技术对于特化的泛型是不可能的，这意味着它们必须以不同的方式表达，而且通常成本更高。（没有明白具体说的是什么，可能指例如 <code>instanceOf List</code> 这样的判断）</li>
</ul>
<p>很明显成本和风险是巨大的。那么会有什么好处？之前我们提到了特化的三个可能的好处：反射、布局特化和运行时类型检查。上述论点在很大程度上排除了我们进行运行时类型检查的可能性（运行时成本、不可判定性风险、生态风险以及原始类型实例的存在）。</p>
<p>能够知道 List 的元素类型是什么（也许可以知道，但也可能没有）当然会有一些好处。只是成本和收益相差了几个数量级。（同构翻译的另一个代价是不能支持基本类型作为类型参数，例如必须使用 <code>List&lt;Integer&gt;</code> 而不是 <code>List&lt;int&gt;</code>）</p>
<p>普遍认为擦除是不好的 hack 的误解，通常源于缺乏对替代方案的真实成本的认识，包括工程工作量、时间周期、交付风险、性能、生态影响和便利性，鉴于已经编写的大量 Java 代码以及在 JVM 上运行的 JVM 实现和语言的多样化生态。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Valhalla (1): 背景 How We Got the Generics We Have</p><p><a href="https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/">https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Xinyu Liu</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-08</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-12-26</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> CC BY-NC-SA 4.0</a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/java/">java, </a><a class="link-muted" rel="tag" href="/tags/jvm/">jvm </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/jep-390/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Valhalla (5): 解读 JEP 390 Warnings for Value-Based Classes</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/valhalla/"><span class="level-item">Valhalla (0): 序言</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/disqusjs/1.3.0/disqusjs.css"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script src="https://cdnjs.loli.net/ajax/libs/disqusjs/1.3.0/disqus.js"></script><script>new DisqusJS({
            shortname: 'alphalxy-blog',
            apikey: ["5vNlbaVFbUWJEfg45a4W2eS1pGk6YDf3BoRmbUt5oCteUtJalJxdik6EgZWDGICC","M6U0tycmlOwkeadjgjGrrUYJZzR7LFakiur7ad78eImTGkJjqU1lFgHXAPzZHNb8","lVltbGH4pPUYFwdOi0JDh1hmwMRtuUF05Yyc1MyBUoJRBQhn4wQoG90VB0j3N1NJ","uQbbc193Lwj7pyDJRszhRZRs6Kl7PPfpVjAgfN46WNmUoFaqTpiZ7dxkPYL13NNZ","mu8gCIMF7kJw1sxvCsrndjV8HfRzswjS38kjPkpimTIfZ3DmSvA3UK3r7WWVLdNJ"],
            siteName: "Alpha Lxy",
            identifier: "2021/10/how-we-got-the-generics-we-have/",
            url: "https://www.alphalxy.com/2021/10/how-we-got-the-generics-we-have/",
            title: "Valhalla (1): 背景 How We Got the Generics We Have",
            api: "https://disqus.skk.moe/disqus/",
            
            
            
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/favicon.svg" alt="Xinyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xinyu Liu</p><p class="is-size-6 is-block">liuxinyu0922@163.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hangzhou, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">Posts</p><div><p class="title">14</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">Categories</p><div><p class="title">7</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">Tags</p><div><p class="title">11</p></div></div></a></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.github.com/AlphaLxy" target="_blank" rel="noopener"><i class="fab fa-github"></i>  Follow</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#系列文章（未完待续）"><span class="level-left"><span class="level-item">1</span><span class="level-item">系列文章（未完待续）</span></span></a></li><li><a class="level is-mobile" href="#擦除-Erasure"><span class="level-left"><span class="level-item">2</span><span class="level-item">擦除 Erasure</span></span></a></li><li><a class="level is-mobile" href="#同构与异构翻译-Homogeneous-vs-Heterogeneous-Translations"><span class="level-left"><span class="level-item">3</span><span class="level-item">同构与异构翻译 Homogeneous vs. Heterogeneous Translations</span></span></a></li><li><a class="level is-mobile" href="#在-Java-中擦除泛型-Erased-Generics-in-Java"><span class="level-left"><span class="level-item">4</span><span class="level-item">在 Java 中擦除泛型 Erased Generics in Java</span></span></a></li><li><a class="level is-mobile" href="#有没有替代方案-Why-What-were-the-Alternatives"><span class="level-left"><span class="level-item">5</span><span class="level-item">有没有替代方案 Why? What were the Alternatives?</span></span></a></li><li><a class="level is-mobile" href="#逐步迁移兼容性-Goal-Gradual-Migration-Compatibility"><span class="level-left"><span class="level-item">6</span><span class="level-item">逐步迁移兼容性 Goal: Gradual Migration Compatibility</span></span></a></li><li><a class="level is-mobile" href="#内存污染-Heap-Pollution"><span class="level-left"><span class="level-item">7</span><span class="level-item">内存污染 Heap Pollution</span></span></a></li><li><a class="level is-mobile" href="#JVM-生态-Context-Ecosystem-of-JVM-Implementations-and-Languages"><span class="level-left"><span class="level-item">8</span><span class="level-item">JVM 生态 Context: Ecosystem of JVM Implementations and Languages</span></span></a></li><li><a class="level is-mobile" href="#擦除是务实的妥协-Erasure-was-the-Pragmatic-Compromise"><span class="level-left"><span class="level-item">9</span><span class="level-item">擦除是务实的妥协 Erasure was the Pragmatic Compromise</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Alpha Lxy" height="28"></a><p class="is-size-7"><span>&copy; 2023 Xinyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="AlphaLxy GitHub" href="https://www.github.com/AlphaLxy"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>